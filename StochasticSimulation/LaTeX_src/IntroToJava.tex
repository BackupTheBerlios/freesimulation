%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction to Programming in Java}
\label{chap:IntroJava}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Programming in Java}
\label{sec:Programming}


\subsection{General Considerations}
\label{sec:General_considerations}
This book is about stochastic simulation methods and their applications to
physical systems. The material is presented at an introductory level. We do 
not assume any prior knowledge on probability theory or on the theory of 
stochastic processes. We assume only the material known from the introductory 
courses in theoretical physics. The style of the presentation will be as 
informal as possible and as precise as necessary.



\subsection{Programming Languages -- Why Java ?}
\label{sec:Programming_languages}
It is clear that it is not possible to teach simulation methods without 
performing some numerical experiments in the classroom and that it is 
impossible for the students to learn stochastic simulation methods without 
implementing the algorithms. Therefore, the theory and the corresponding 
algorithms will be presented in a highly interconnected, and, we 
hope, organic way.

In order to stick to this idea it was necessary to choose a programming 
language. The obvious criteria for taking such a decision are
\cite[]{GARCIA}
\begin{enumerate}
\item Efficiency,
\item Understandability,
\item Good graphics,
\item Standard/Portable,
\item Cost,
\item Parallelizability.
\end{enumerate}
The first criterion is of course very important because already simple 
stochastic algorithms require a considerable amount of CPU time.
A secondary aim of the course is to make the student acquainted with a 
programming language ``in action'' so they should learn something 
about a ``good 
programming style'' for real-life problems. Visualization of the results 
obtained allows to understand in a plastic way what is going on physically. So 
the interface between program and visualization tool/graphical output should
be comfortable. Last not least the availability of the program should be
guaranteed. The corresponding compilers should be available at low, in the 
ideal case at no cost to the students for home exercises. Furthermore, they
should be portable on PCs with Windows or Linux operating systems, on Macintosh
and on workstations from the UNIX world (IBM AIX, Solaris, SGI Irix, ...).
Since almost all universities do have a high--performance parallel computer 
the language should also allow to demonstrate high--performance parallel 
algorithms.

Because of our background of convinced Fortran users we considered the 
following alternatives: our beloved Fortran, MATLAB, a language which 
is popular in 
the engineering and applied mathematics communities, and Java, the 
``Wunderkind'' of software developers and of the Internet community. We have 
not considered C, C++ for the simple reason that we never felt the necessity 
to learn them.

All the languages considered  in some sense satisfy the above criteria. All
are more  or less portable on different platforms (at different expenses), all
allow the use of good visualization tools (at different prices), and, of 
course, all are clean. But not all are equally powerful. 

We checked the power (the efficiency) of the languages considered by the 
following benchmark, which represent the prototype of a stochastic simulation. 
We generated 100 trajectories of a typical one-step stochastic process
and compared the CPU times obtained by different languages. The result
of the benchmarks are summarized in Table \ref{tab:Performance}. The listings
of the corresponding programs are presented in the appendix.

\begin{table}[htbp]
  \begin{center}
    \leavevmode
    \begin{tabular}{llp{3cm}|c|c}
      Language & OS & Software & Machine & CPU time \\\hline\hline  
   Fortran 90 & Linux & Nag f90 Compiler V2.2(260) & Pentium 133 & 2.1 sec.\\
           & Linux & Nag f90 Compiler V2.2(260) with -O3 & Pentium 133 & 2.4 sec.\\
           & Linux & Nag f95 Compiler V1.0(436) & Pentium 133 & 2.3 sec.\\
           & Linux & Nag f95 Compiler V1.0(436) with -O4& Pentium 133 & 2.3 sec.\\
\rowcolor[gray]{0.85} & Linux & Pallas f95 Compiler V3.0-3 & Pentium 133 & 1.3 sec.\\
           & Linux & Pallas f95 Compiler V3.0-3 with -O4& Pentium 133 & 1.4 sec.\\\hline
   C       & Linux & GCC 2.7.2.3 & Pentium 133 & 2.1 sec. \\
\rowcolor[gray]{0.85} & Linux & GCC 2.7.2.3 with -O3 & Pentium 133 & 2.0 sec. \\\hline
   C++     & Linux & egcs-1.0.3 & Pentium 133 & 2.2 sec. \\
           & Linux & egcs-1.0.3 with -O3 & Pentium 133 & 1.8 sec. \\\hline
      Java & Linux & JDK 1.1.7, no JIT & Pentium 133 & 16 sec. \\
\rowcolor[gray]{0.85} & Linux & JDK 1.1.7, with JIT TYA (V1.3) & Pentium 133 & 10 sec.\\
           & Linux & JDK 1.1.7, no JIT & DEC Alpha 21164 600 & 6 sec. \\
           & Win95 & JDK 1.1.7, with Symantec JIT & Pentium 133 & 9 sec. \\
           & Win95 & JDK 1.1.7, no JIT & Pentium 133 & 19 sec. \\
\rowcolor[gray]{0.85}  & Win95 & JDK 1.2, with Symantec JIT & Pentium 133 & 8 sec. \\
           & Win95 & JDK 1.2, no JIT & Pentium 133 & 22 sec. \\\hline
   Matlab  & Win95 & Matlab 5.1 & Pentium 166 & 330 sec.\\
\rowcolor[gray]{0.85}  & Win95 & Matcom Compiler V3.0 with Borland C++ 5 & Pentium 166 & 70 sec.\\
           & Linux & Matlab 5.2 & Pentium 133 &  224 sec.\\\hline
   Maple   & Linux & Maple V Rel. 4 & ??? & \\\hline
Mathematica& Win95 & Mathematica V3.0 & Pentium 133 & 28 Min. \\
\rowcolor[gray]{0.85} & Win95 & with Compiler    & Pentium 133 & 26 Min. \\ \hline
    \end{tabular}
    \caption[Performance Table.]%
    {Performance comparison for different languages, operating
      systems (OS), and platforms.
      The test program is a one-step stochastic process. We create 100
      realizations, $g(n)=0.4n, r(n)=0.5n$. On Windows 95 the JIT from
      Symantec is included and automatically used, when executing programs
      with the java command in the JDK. The TYA JIT for Linux is freely
      available and easy to install. Usage: with the Java virtual machine of
      the JDK use \texttt{-Djava.compiler=tya} or 
      set the environment variable \texttt{JAVA\_COMPILER=tya}. To avoid
      using the JIT use option \texttt{-nojit} up to JDK1.1.7 on Windows or
      for all other platforms set the environment variable 
      \texttt{JAVA\_COMPILER=none}.
      }
    \label{tab:Performance}
  \end{center}
\end{table}


Of course, in the above test we have not optimized the algorithm to the 
different platforms. Nevertheless, the table clearly shows that MATLAB is 
very slow. Even the compiled version of MATLAB is slower by a factor of 
about 100 
compared to the Fortran code. This is a good reason to disregard MATLAB!

Now we have to decide between Java and Fortran. As can be read off from
the Table \ref{tab:Performance} the criteria of numerical efficiency
clearly speaks for Fortran. The argument in favour of 
Java which compensates the slightly slower performance (today!, in future 
this might be different) is its portability and the free availability of the
compiler and of the visualization tools. Java runs on every platform and 
it is available at no cost. 

There is also a compiler called High Performance Java by IBM. It generates
much faster code on an workstation. For a comparison with this
compiler see \cite[]{HPJ}.

Last not least, we want to mention another advantage of Java. It seems
\cite[]{bigbucks} that there is  a great need for Java programmers in 
different branches of industry today. This need will be even greater in future 
years. So learning Java, might be a kind of ``life insurance'' for students of 
physics. It will put them in the position to find a good  job in the
software industry.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Java}
\label{sec:Java}

We have just seen some good reasons to choose Java as the programming language
for our purposes. Here we want to mention some more technical points, from a 
computational science point of view, in favour of Java.

SUN Microsystems has described Java as follows \cite[]{javanutshell}:
\begin{quote}
Java: A simple, object--oriented, distributed, interpreted, robust, secure,
architecture neutral, portable, high--performance, multi-thread, and dynamic 
language.
\end{quote}
Let us try to understand roughly what is meant by the above adjectives.

Java is simple in the sense that the number of language constructs has been 
kept as small as necessary. For ease of migration from other languages some
basic language elements resemble C or C++. However, some features of these 
languages which were rarely used and which have been considered to be unsafe 
have been omitted. For example, in Java there is no \verb|goto|
 statement; instead 
it has labelled break and continue statements. The preprocessor of C has been 
eliminated; the program you write is the program that the compiler sees. In 
Java there are no  operator overloading and no multiple inheritance 
features of C++. (But you can use interfaces to simulate multiple inheritance
and argument overloading is possible.)
One major simplification is that Java does not have pointers!
In Java memory is managed automatically, so the programmer is not responsible 
for the management  of memory space. In particular Java implements an 
automatic  garbage collector.

Java is an object--oriented language and you do not have to think in a 
procedural--based way, as it is the case in Fortran for example. In order to 
solve problems in Java you have to use the notions of classes and objects. 
Every object has a class that defines its data and the methods that operate 
on these data. Classes are hierarchically arranged. A subclass inherits the 
behaviour of its superclass. A class is the basic unit of compilation
and of the execution in Java. All Java programs are classes.
Of course you do not have to use the object oriented programming style,
you can still stick to the procedural style in Java too.

Java is a distributed language, which simply means that it provides a lot of 
tools for networking. Java is the programming language of the Internet.

Java is an interpreted language. The Java compiler compiles the Java
source code into Java byte--code, which is the machine language for the Java
Virtual Machine (JVM). The JVM is an abstract machine which runs on each system
that supports Java. Other languages may also be compiled into Java byte-code.

Java is robust. Java contains features, called 
exception handling, which simplify the
tasks of error handling and recovery.

Java is secure. Since Java has been designed for distributed applications
high security standards have been implemented. For example, direct access to
memory is not allowed. Java contains four different levels of security 
checks and enforcements to prevent the introduction of viruses. 
In particular there is protection against deleting and modifying files.

Java is architecture neutral and portable. The byte-code format is always the 
same regardless of the platform on which the Java compiler runs. Furthermore,
there are no ``implementation defined'' behaviours in Java. For example, Java
specifies the size of each primitive data type. The integer 
types byte, short, int, long are 8, 16, 32 or 64--bit long, respectively.
This also avoids the use of any preprocessor available to all other
languages, most notably used excessively in C and C++ to catch all
platform relevant parameters.

Java is a high--performance language. 
Usually implementations of Java are used running 
Java programs interpretatively. It is however possible to run Java with a 
Just In Time (JIT) compiler. JIT compiling increases the performance of Java 
considerably.

Java is multi-threaded. It supports multiple threads of execution which can 
handle different tasks. Multi-threading increases the interactive performance 
of Java.

Java is dynamic. Any Java class can be loaded into a running Java interpreter 
at any time.

Java includes the zlib compression library in the 1.1. language specification.
These are
the freely available compression libraries used in the well-known
gzip compressor.
That makes it very easy to write and read compressed data. 


\subsection{Brief History of Java}
Java started off in 1991 as a project by James Gosling, which at that 
time was called
Oaks. Its purpose was focussed on the use as operating  
software (OS) for consumer
electronic devices. A small group decided to adapt Oak to web
technology and released the first version of Hotjava (a web browser, at that
time still called WebRunner)
in late 1994. After a presentation given by James Gosling about the 
byte codes used by Oak in 1995, the new language JAVA was officially 
announced in April 1995 (Java 1.0), 
including the first official release of Hotjava.
The announcement was the source of a hype, because Java is ideally
suited for the heterogenous world of networked computers seen today and
the Java philosophy allows for ``Write Once, Run Everywhere'' including
graphical capabilities.

Then in January 1996 the first version of the Java Development Kit (JDK) 
was released by SUN. Soon the language was licensed by many companies,
most notably Netscape, which included a Java Virtual Machine (JVM) into
their widely used browser Netscape Navigator. Then in early 1997
SUN released the second version of Java: the new language specification 
Java 1.1 and the development kit for it, JDK 1.1.

Meanwhile most of the browsers adapted the new Java 1.1 language specification.
Also many new APIs (Application Programmers Interfaces) like Java 3D or 
most important the JFC\footnote{The Java Foundation Classes, which
consist of the Swing API and many more components like (an 
almost complete set of)  
the Internet Foundation Classes (IFC). You can either use Java 1.1 together
with the JFC 1.1 for Swing 1.1 or Java 2, which already includes JFC 1.1 for
Swing 1.1 and also Java 2D and some more new APIs.}
have appeared, some
of them have been officially included in the Java 1.2 specifications
(now called Java 2). Together with the JDK 1.2, Java 2 appeared in January 1999.
But no browser supports this standard right now, although most
of the software available for Java and written in Java seem to be
already adapted to the new standard. Another change occurred to the
licensing of the JDK: it is now almost Open Source Software, which
means you can have the source code and change it, you only have to make
sure it still conforms to the Java standard.

At the same time SUN released a new project called JINI, which is
a ``small set of instructions and interfaces'' based on Java to
be used to drive and use arbitrary electronic devices in a local network--
the actual aim of the Oaks/Java project started in 1991. The idea is that every 
JINI device reports to a ``naming service'' and tells it, what services
it provides to the network. The server can then tell, what services are at
all available to somebody at some place. The device therefore can be 
taken to any place in the world and used in any JINI network to which
it gets connected. You do not even need a JVM in the device, you can 
use a JVM supplied by a different device (e.g. a computer or browser) 
available in the network. The whole system is based on Java code and
the RMI protocol supplied by Java.


%%%%%%%%%%%%%%%%%%%%%%
\section{Tools for Writing and Using Java}

\subsection{Programs:} 
\begin{description}
\item[JDK] The Java Development Kit, distributed freely by SUN.\\
        This kit is available for almost all platforms, e.g. Windows,
        Solaris, Macintosh, Linux, etc. This is the first package to get,
        to use Java. It consists of a Java compiler, a virtual machine 
        and a debugger. There
        are of course many other compilers, JVMs and debuggers
        available, but this is the place to start with. A disadvantage
        of the JDK for Windows user is, that you have to use the
        command line to use it. There are no graphical interfaces  coming with the
        package to start, compile or debug Java programs.
\item[MRJ/SDK] Apple develops the Java developement kit for the Macintosh and
  distributes two versions: the MRJ runtime environement (in version 2.0 included
  in MacOS 8.5 and the new version MRJ 2.1.2 from \href{http://developer.apple.com/java/}%
  {http://developer.apple.com/java/}) and the SDK for Macintosh in version
  2.1 as of the time of writing also available from the address above. These are
  versions supporting Java 1.1.7 and Swing/JFC. The new version MRJ 2.2
        is just getting available.
\item[Emacs/XEmacs] This is an editor available for most platforms.\\
        We basically use this very powerful but sometimes confusing
        editor to do all our programming, text editing and more. It is
        also available for Windows, but it is mostly used on UNIX machines.
        You are of course free to use ANY editor you like, which is available
        to you. 
\item[JDE] JDE (Java Development Environment) is an Emacs/Xemacs extension
        written in Elisp. \\
        It enables you to write Java code in a shorter time, if you are
        using the emacs or xemacs editor. 
\item[mpEdit] A freely available editor written completely in Java and
  therefore available on all platforms.\\ 
  It has all necessary features to write Java/C or C++ programs.
\item[Netscape Navigator/Communicator] A web browser like the Internet 
        Explorer, but written by Netscape inc. and the source code is
        freely available and fully conforming to the Java standard. \\
        We used Netscape and the appletviewer of the JDK to test all
        the applets in this book.
        Be aware that not everything is supported by all browsers and
        sometimes you get strange results or the browser crashes,
        although the program did run with the appletviewer.
\item[Java Workshop] A commercial Integrated 
    Development Environment (IDE)        
  for Java by SUN. Free trial versions
  for universities and educational institutions are available.
        Unfortunately it produces not very readable code for later
        editing.  
\item[Freebuilder] A freely available IDE for Java. \\
  Already in a usable state, although it is officially in alpha stage.
\item[Netbeans] A commercial IDE for Java written in Java \\
  This is an object oriented IDE for Java. It is free for academic and 
  personal use, but not for commercial use.
\item[Simplicity] A commercial IDE for Java written in  Java\\
  A very nice and easy to use IDE for Java. It is very easy to get started
  with it and it even can write event handling code for your 
  graphical user interfaces (GUI).
\item[TOBA] A Java to C Compiler for Linux\\
  It converts Java source code to C and compiles the C code to get better
  performance. It runs on Linux, Solaris and IRIX and supports Java 1.1.
  It seems to be no longer developed (April 99).
\item[Fortran to Java] A Fortran 77 to Java Compiler. \\
  You can convert very easily Fortran 77 programs to Java. This is a part of the
  ``Java Access to Numerical Libraries'' project at the University of 
  Tennesee in the US. F2j was already capable of translating the
  Lapack routines to Java.
\end{description}

\subsection{Java Packages:}
\begin{description}
\item[simulation] This is the package developed during the writing
        of this book. It provides only some very basic features, which
        might be of interest or can ease writing code. Some source
        code of freely available software have been included for
        convenience, adhering to the softwae licenses of course. 
\item[Ptolemy (Ptplot)] A package to produce 2D plots from data. \\
        Ptolemy (version 1.0 from January 1999, which includes version
        2.0 of Ptplot.)
        is actually a whole set of useful packages, but so far only the
        plot package, called Ptplot is currently fully functional. We will
        use it extensively for all plotting in 2D. It has a nice
        zoom feature and it allows for the most important plot styles
        needed.
\item[JNL] The Java Numerical Library written by Visual Numerics and
        distributed freely\footnote{But please consult the License Agreement
        coming with the software.}. It is also submitted to the standardizing
        committee for proof to include it in the next release of the
        Java language specification to become a standard. \\
        The JNL includes the basics for using complex numbers, it
        provides some important standard functions (hyperbolic
        functions, Gamma function, etc.) and it provides 
        the basic operations for statistical data analysis (e.g. mean,
        variance, linear least square fit, etc.). It also provides some
        basic functionality for linear algebra, like matrix decomposition,
        determinant, trace, solving linear systems, etc.
\item[JSci] A freely available package with support for many 
  physics constants, mathematical operations, etc. \\
   It includes methods for fast Fourier transformations, ordinary differential 
   equations, complex numbers and much more. We prefer to use the JNL
   implementation of the complex number classes, because they will
   more probably become the standard.
\end{description}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basic Elements of Java}
\label{sec:Basic_elements_of_Java}
Like in other languages to write a program you first need an editor
to type the source code. Second you need a compiler to translate
the Java code to byte-code. And last, in contrast to most
traditional languages like C, C++ and Fortran, we need a virtual
machine (interpreter, called JVM) to execute the byte-code.

\begin{figure}[htbp]
  \begin{center}
    \leavevmode
    \includegraphics[width=\textwidth]{Figures/Java_Overview.eps}
    \caption{Overview of the Java language execution model.}
    \label{fig:Java_Overview}
  \end{center}
\end{figure}

So for every platform, where a virtual machine is available,
you can execute the byte-code without any compatibility problems.
But the ``look and feel'' can be different, for example Java buttons
in Windows look different from buttons in X11/Motif using a UNIX
operating system. But if you use the new Swing components supplied
with the Java 2 standard or extend the Java 1.1 standard with the Swing
components, you can choose the appearance of the graphical look, which then
is the same across all platforms. So if you are using the new Java 2 standard
(JDK1.2), you should definitely use the new Swing components. If you
still use the AWT components (like we do here in this book), you should
keep in mind that the look (not the functionality) 
of the program can be different on different platforms. 
A big advantage of the Swing components is that they do not use any
native code, which the AWT components do.

The main reason for the wide availability of Java
is that SUN Microsystems distributes the Java Development Kit (JDK)
freely for a number of important platforms (Windows, Solaris/Linux,
other Unix systems). The JDK consists of a compiler (javac), a
debugger (jdb) and a virtual machine (java)\footnote{Actually there
are some more components like the javadoc command to create HTML
documentation or the jar tool to create zipped packages of
class files belonging together - see later on.}.

The JDK can be downloaded from the internet from the 
\href{http://www.javasoft.com}{JDK Javasoft link page}.
The newest version (as of the time of writing) is 1.2. 
Throughout the book,
we will use the Java 1.1 language version and the JDK 1.1.7,
because the Java 2 standard is not yet implemented in any JVM of the
web browsers available.

The only additional thing necessary to have a Java programming
environment is an text-editor to write the Java programs. For that
you should use your favorite editor, e.g. emacs or xemacs, which are
also freely available and have nice Java editing modes.

There is also a freely available IDE (Integrated Development 
Environment) called \href{http://www.freebuilder.org/}{FreeBuilder}.
This is a complete environment to write Java programs comfortably,
which is the first under the GNU license. It is still in alpha
development stage, but it already comprises a lot of features. Of
course, there are many commercial ones available, like SUN's Java Workshop
or \href{http://www.datarepresentations.com/}{Simplicity for Java}.


Opposing to other languages, which use the ASCII character set, Java
uses the Unicode character set \href{http://unicode.org}{(to the 
Unicode WWW Homepage)}. 
Unicode consists of characters represented
by 2 bytes instead of 1 byte like in the ASCII set. So you can not only
use 256 different characters (ASCII) but you can use all the 38885 different
characters available in the Unicode set (Version 2) for writing a Java program.
This means you can name your variables using for example Japanese or Greek
characters. Right from the beginning, Java is an international language.

Java is also case sensitive and doesn't need any special characters
to mark continuation lines. 

Comments are used just like in C and C++.
You can use either the /* \ldots */ syntax (borrowed from C) for
multi-line comments or the // syntax (borrowed from C++) for single
line comments. Additionally you can use /** \ldots */ for comments
to automatically generate a HTML documentation file for the class
defined in the file. We will see later on how this can be achieved.
 
There are also certain disadvantages, which should not be forgotten
to mention: The learning curve is certainly steeper for the beginner
for Java than for Matlab or even Fortran. This is of course due
to the full use of the object oriented approach used for all Java
programs. This clearly shows up, when we will introduce e.g. the
file and keyboard input/output capabilities of Java.
But in the long term learning Java definitely pays off. 

A second point to note is, that for scientists a big concern are always
complex numbers. They are currently not supported as primitive types as 
in Fortran for example, but there are (standardized) packages, which
add complex number support to Java (e.g. JNL). 


\subsection{The ``HelloWorld'' Program -- Applications and Applets}
\label{sec:HelloWorld}
Now let us start with the traditional ``Hello World'' program written
in Java.

\subsubsection{Application}

\inputlisting{Listings_Java/HelloWorld_Application.java}
You have to save the program in a file called 
\verb|HelloWorld_Application.java|.
To execute the above example you have to type in the commando line the
following:
\begin{itemize}
\item Compiler: \verb/javac HelloWorld_Application.java/  \\
  $\Longrightarrow$ produces HelloWorld\_Application.class 
  in the same directory.
\item JVM:  \verb/java HelloWorld_Application/
\item Output on screen: \verb|Hello World !|
\end{itemize}
Let us now try to understand the above code. The program consists of
three lines. 

In the first line the program declares 
with the help of the \texttt{class} statement a class called 
\verb|HelloWorld_Application|. 
The identifier following the \texttt{class} statement is
the name by which the class will be referenced. Each Java program
is a class. The curly bracket appearing after the class name
\verb|HelloWorld_Application| introduces the following class member. 


In the second line the \verb|main| method is introduced. The main
method is declared \verb|void| because the method does not return a
value. The main method is executed when you run the class as an
application. The only parameter, the argument
of the main method, is an array of String object.

In the third line the method \verb|println()| of the system class 
\verb|out|
is invoked. This method simply prints a string and terminates with a 
new--line command. Alternatively you could use the 
\verb|System.out.print()| method, which does the same, but does
not print a newline at the end. 

You have just written and executed your first application in
Java. Please, do not worry if you do not understand everything. You are
not expected to understand everything at this stage.

If you are using Emacs/Xemacs and JDE you could have started Emacs and
then just used the ``JDE New'' method in the ``Files'' menu. Then you
have to type the \verb|System.out.println()| code, which could
again be accomplished by using the \verb|Generate| menu in the
JDE menu. To compile
use the ``compile'' command in the ``JDE'' menu and similar
the ``run'' command in the same menu. This saves you a lot of keystrokes. 

\subsubsection{Applet}
\label{sec:Applet}

Java offers another possibility to execute code, so called Applets.
In contrast to the stand--alone Java application which starts at
\verb!main! and runs until it is completed, the applet is a kind of
sub--program which runs under the control of some other program.
Usually, applets are (small) Java programs, which are started by a 
server program,
e.g. a WWW browser like Netscape Navigator\footnote{You need at least 
version 4.06 or patches for earlier versions to use all features of Java 1.1}, 
the Internet Explorer\footnote{Seems to run Java 1.1 programs since
version 4, but does not conform to the Java standards.}(Don't),
HotJava or the appletviewer\footnote{included with the JDK.}.

In the case of an applet, you have a browser loading a HTML 
(Hyper Text Mark-up Language) file. This HTML file contains
mark-ups, which tell the browser what applet to load and
where to find the applet (see figure \ref{fig:HTMLOverview}). 
\begin{figure}[htbp]
  \begin{center}
    \includegraphics[width=\textwidth]{Figures/HTMLOverview.eps}
    \caption{An HTML file gets loaded into the browser. The browser itself formats the text and if it finds an applet mark, it starts the applet.}
    \label{fig:HTMLOverview}
  \end{center}
\end{figure}
You should note that HTML is not a programming language, but
it is a mark-up language to produce a text with additional
``commands'' for the meaning of the text parts. It does also
not give any details about the formatting or layout of the
text. To start an applet HTML has some special marks, which we
will see in a moment.  

The big difference between an applet and an application is that
applets are not allowed to do certain things. For example applets
do not have access to local file systems, so it is not possible
to save data on the file system from an applet. It is also not
possible for an applet to issue a print command, the process of
printing has to be initiated by the server (browser). 
And an applet is not allowed to do time consuming tasks like
long computations. This has to be kept in mind, when writing
applets.

You can actually have applets accessing the local file system by using
``signed applets''. These are applets having a signature coming
with them (in the JDK you use \verb|javakey| for that purpose), 
which is checked by the server before the execution. So
if you have signed your own applet and tell your browser to accept 
all applets signed with your signature, you can use file commands
inside your applets (see \cite[page 142]{javanutshell}).

The ``Hello World'' example written as an applet has the following form:
\inputlisting{Listings_Java/HelloWorld_Applet.java}

Applets have to be derived from the applet class
\verb|java.applet.Applet|, which include the principal facilities of
the Abstract Windowing Toolkit (AWT) and the interface with X/Motif on
Unix, Windows on PC, and Mac-OS on Macintosh platforms.
As you can see there is no main method in an applet. Instead if an applet
is started by a server, the init() method is executed first. There is also
a start() (stop()) method, which is executed if the applet becomes
visible (disappears) in the server window (e.g. by scrolling in the
Netscape Navigator window).

Many methods are available to set up the display in an assigned applet area.
The paint() method appearing in the ``Hello World'' applet is
responsible for the visual part of the applet. It uses a canvas
(drawing area) with a size defined by the calling HTML file. In our case
this HTML file could look like:
%% Listings V0.20 ERROR ?????
%%\lstinputlisting[language=HTML]{Listings_Java/call_HelloWorld_Applet.html}
\lstinputlisting{Listings_Java/call_HelloWorld_Applet.html}
The code parameter given in the HTML file defines the name of the applet
to be run. Because there is no init() and no start() method in our
example, the paint() method gets executed by the browser (or appletviewer).
The size of the canvas has to be given in pixels explicitly in the
HTML file.

To run the applet you can either type
\begin{itemize}
\item \verb|appletviewer  call_HelloWorld_Applet.html| or
\item use the following URL in the browser: \\
        \verb|PATH_TO_CLASS_AND_HTML_FILE/call_HelloWorld_Applet.html| \\
        e.g. \verb|/home/user/java/call_HelloWorld_Applet.html|
\end{itemize}

The question, when to use an application and when to use
an applet, is difficult to answer. We have decided to write most
of the programs as applications and applets in one program. So you
can decide if you run it as an application or start it as an applet.
Some features are of course not available from an applet and
you are missing some functionality of some programs, if you run them
as an applet.
Time consuming calculations should
definitely be written as an application, small programs can be
written as an applet. Although this is not mandatory it should
be obeyed by a good Java programmer.

In Java 1.1 a new package (see later) was introduced, which allows
so called ``trusted applets''. These are specially signed libraries,
which are signed with a key by a person you trust. Only if the
signature is valid and you trust that person, the ``trusted applet''
has access to the local files system -- basically it can do everything
an application could do on your machine. This is already implemented with
the appletviewer, in different ``servers'' it might work or not. In the
future this will be extended to a more extensive set of rules for the
allowed methods of an applet.

\paragraph{Documenting Java Programs -- javadoc}
A last remark concerns the documentation for the programs. We have
learned, that we can include documentation comments using 
\verb|/** .... */|. These comments are processed by using the
\verb|javadoc| command from the JDK. If you run the javadoc command as: 
\begin{sverbatim}
  javadoc HelloWorld_Application.java HelloWorld_Applet.java  
\end{sverbatim}
you get some HTML files: packages.html, tree.html, AllNames.html,
HelloWorld\_Applet.html, HelloWorld\_Application.html. All these
files describe the written classes. The tree.html file gives a tree
showing the relatives of the class. The package.html gives the
package structure (not used here). The most important file is the
AllNames.html, which is an index of all written programs in this package
(for an introduction to packages see later).

You can even include special predefined strings to supply the
author and many more informations to the javadoc command, either
for a class or a method, whereas the documentations for the method
can also be supplied for a class:
\begin{lstlisting}{}
  /**
      @author Peter Biechele
      @version 1.0
  */
  .. class ... { }

  /** 
      @see <a class name>
      @see <class name>#<method name>

      @param  a b c
      @return d
      @exception  none
  */
  .. method ... { }
\end{lstlisting}

This of course gives us the opportunity to write our 
explanations/documentation
between the \verb|/** .... */| commands using HTML constructs like
\verb|<hr>| for a horizontal rule or others - try it. 
Because this code gets directly included in the HTML files produced by
the \verb|javadoc| command, you can have nicely formatted documentation.
But you should avoid using \verb|<h1>| to \verb|<h6>| -- the heading 
commands -- because javadoc uses them for its own structure.

If you load AllNames.html into a browser, you get the HTML file shown
in figure \ref{fig:javadoc1}.
\begin{figure}[htbp]
  \begin{center}
    \leavevmode
 \includegraphics[width=8cm]{Figures/AllNames.eps} 
    \caption{The output of the \texttt{javadoc} command from the JDK 1.1.}
    \label{fig:javadoc1}
  \end{center}
\end{figure}
Now you can click on the link HelloWorld\_Applet and you get the
documentation for that class and analogous for the HelloWorld\_Application
class (see figure \ref{fig:javadoc2}).
\begin{figure}[htbp]
  \begin{center}
    \leavevmode
  \includegraphics[width=6cm]{Figures/HelloWorld_Applet.eps}
  \includegraphics[width=6cm]{Figures/HelloWorld_Application.eps}
    \caption{The output of the \texttt{javadoc} command from the JDK 1.1.}
    \label{fig:javadoc2}
  \end{center}
\end{figure}
The missing graphics on the right of figure \ref{fig:javadoc2} 
are available in the Java documentation of the
JDK and just has to be copied into a subdirectory  
of the HTML directory called \verb|images| . 
Then it looks like the figure on the left.

The javadoc command of the JDK 1.2 produces much nicer pages which
look like in figure \ref{fig:Java2HTMLDoc}. There are no separate 
gif pictures
needed anymore and the structure of the classes is represented
much better.
\begin{figure}[htbp]
  \begin{center}
    \subfigure{\includegraphics[width=.3\textwidth]{Figures/HelloWorldApplet1.eps}}
\quad \subfigure{\includegraphics[width=.3\textwidth]{Figures/HelloWorldApplet2.eps}}
\quad \subfigure{\includegraphics[width=.3\textwidth]{Figures/HelloWorldApplet3.eps}}
    \subfigure{\includegraphics[width=.45\textwidth]{Figures/HelloWorldApplication1.eps}}
\quad \subfigure{\includegraphics[width=.45\textwidth]{Figures/HelloWorldApplication2.eps}}
    \caption{The output of the \texttt{javadoc} command from the JDK 1.2.}
    \label{fig:Java2HTMLDoc}
  \end{center}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Variables}
\label{sec:Variables}

Essentially, Java distinguishes between two types of variables,
primitive data types and reference data types.
\subsubsection{Primitive data types}
\label{sec:primitive_data_types}
We already mentioned that in Java each variable or expression has a
definite type and that each type has identical size and behaviour on
all Java implementations.  Java has built in primitive data types
to support integer, floating--point, boolean, and character values.
The primitive data types of Java for integers, floating--points,
characters and boolean variables are listed in Table
\ref{table:primitivedata}.
\begin{table}[htbp]
\label{table:primitivedata}
\begin{center}
\begin{tabular}{l|l|l|l|l}
Type & Contains & Default & Size & Min \\
     &          &         &      & Max \\ \hline \hline
byte  & signed integer & 0 & 8bits & -128  \\
&&& & 127    \\ \hline
short & signed integer & 0 & 16 bit &-32768 \\
&&& & 32767 \\ \hline
int &   signed integer & 0 & 32 bits&-2147483648 \\
&&& &2147483647 \\ \hline
long & signed integer & 0 & 64 bits &-9223372036854775808\\
&&& &9223372036854775807\\ \hline
float & floating--point & 0.0 & 32 bits &$\pm$1.40239846E-45\\
&&& &$\pm$3.40282347E+38\\ \hline
double & floating--point & 0.0 & 64 bits &$\pm$4.94065645841246544E-324\\
&&& &$\pm$1.79769313486231570E+308\\ \hline
boolean & true or false      &  false & 1 bit&\\
&&&       &  \\ \hline
char  & Unicode character & $\backslash$u0000 & 16 bits & $\backslash$u0000 \\
&&& &$\backslash$uFFFF   \\ \hline
\end{tabular}
\end{center}
\caption{Primitive data types in Java. The byte and char data types have
  been introduced in Java 1.1 and in Java 2 there was a void type added.}
\end{table}


The following comments have to be made. In a Java program every
variable must have a type that precedes its name when the variable is
declared. For example the integer i may be declared as
\begin{sverbatim}
int i;
\end{sverbatim}
and integer or long values can be expressed as
\begin{sverbatim}
int i = 123; 
long l = 1234567889L;     long l2 = 123456789l;
\end{sverbatim}

Characters are represented by two different data types in Java.
One can store only one character and is called char. The other
one stores many characters like a word or even a sentence. This
second datatype is not a primitive datatype but an object and is
called string. It will be discussed later on.

Char values are defined in Java between single quotes, e.g.
\begin{sverbatim}
char c = 'C';
\end{sverbatim}
Usually characters on a computer are represented internally by a number.
This number is between 0 and 255 and the coding of the characters
to the numbers is called ASCII\footnote{American Standard Code 
for Information Interchange} code. Because not all characters used
for all the different languages in the world are representable by
256 different codes, the codespace has been extended to 65535
numbers and is now called Unicode character set. With this set of
numbers corresponding to characters you can code every language
of the european countries. There are other Unicode sets to represent
more complicated languages like Japanese or Chinese.

A Unicode character in Java is represented by the Unicode escape sequence
$\backslash$uxxxx, where xxxx is a sequence of four hexadecimal digits.

Float and double types have special values that may be the result of
certain floating-point operations. For example in the java.lang.Float
and java.lang.Double classes the special values
\verb|POSITIVE_INFINITY|, \verb|NEGATIVE_INFINITY|, and 
\verb|NaN| (not-a-number) are
defined.

Floating point numbers are expressed as e.g.
\begin{sverbatim}
13.       1.3e1        .13E2 
\end{sverbatim}
and are considered to be constants of type \verb|double| 
unless they are specified with \verb|f| or \verb|F|, which makes them
then \verb|float| constants.

In Java strings are not of primitive type and they are not an
array of chars like in C. Java provides a String
class to deal with sequences of character data. The java string
class provides methods to operate on String objects.

All variables in Java are initialized automatically, as soon as they
are declared. All primitive types get initialized to zero, the boolean type
to false and all objects (remember they are references) are initialized
to \verb|null|. So there is no ambiguity like in other languages, if
a variable has a defined value at certain points of the program. 
Although Java forces you to include sometimes a statement to
initialize variables, just to make easier to read source code.
We will see an example for this later on, when we discuss loops
and calculate averages of sequences of numbers.

\subsubsection{Reference data types}
\label{sec:Reference_data_types}

All non-primitive data types in Java are objects. They are
called also ``reference types'' because they are handled by
reference. For example you may pass the address of an object, which is
stored in a variable, to a method. In contrast, primitive types are
always passed by value.

\subsubsection{Strings and Arrays}
There are two special data types belonging to the reference data types:
the arrays and the strings. Arrays are objects, which have some
special properties and are handled a little bit different from
ordinary objects, just because they are used very often (see section
\ref{sec:Arrays}).

Strings are another special data type belonging to the reference data 
type. In contrast to C and C++ they are not arrays of char variables,
but seperate objects, which can only be accessed as the whole string or
by using special string functions. The strings are also not terminated
by a \verb|\0| like in C/C++, they just contain the text string
assigned to the string object. In the section about arrays, we will learn
how to handle Strings and in the section about objects, we will finally
hear the full story. Actually we hav met strings in out first program
already, because the text between two \verb|"| is a string.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Casting and Type Conversions (Wrapper Classes)}

Java uses a clear strategy to convert the primitive data types to 
other primitive ones. In a calculation Java always converts (casts)
the less precise type to a more precise one. So if you multiply an
integer and a float value, it converts automatically the integer to
a float and then multiplies both values. If you want to convert
a value explicitly you can use the cast operators (like in C and C++).
Just write the primitive type in round brackets in front of the value to
be converted, e.g. \verb|result=(double)a*b| casts \verb|a| to 
a double value and
then multiplies it with \verb|b|, assigning the result to \verb|result|.
You can also use the wrapper classes to be discussed below, but
it is much more complex and should be avoided.

A common problem is to convert from strings to primitive types and
vice versa. Because strings are objects and not primitive types, we
need a method for the conversion. For that reason Java has so called
wrapper classes, subclasses of the \verb|java.lang.Number| class 
for all primitive data types. 
These classes provide all the necessary methods for all types of
conversion. 

The static \verb|.valueOf(String s)| method always converts a string
to the corresponding wrapper class of a primitive type, e.g. 
\begin{lstlisting}{}
        double a;
        String text="+1.234";

        Double D = Double.valueOf(text);
        a = D.doubleValue();

        a=Double.valueOf(text).doubleValue();
\end{lstlisting}
The fourth line converts the string to the \verb|Double| class and in the
fifth line 
the \verb|doubleValue()| method converts the Double wrapper class 
to a double primitive type. The last line shows how to do it in
one line.
For the other types you just have to substitute float or int 
for double, i.e., \verb|floatValue()|, \verb|intValue()| and the
corresponding wrapper class (\verb|Integer| for \verb|Double|, etc.).
 
Another (easier) method, 
later used in the \verb|ParamApplet.java| program is, e.g.,
the \verb|Integer.parseInt(String s)| method, which gives back a primitive
type integer instead of the wrapper class like \verb|valueOf(String s)|.
For other conversions you can use the \verb|Long.parseLong(String s)| or the
\verb|Long.parseByte(String s)| method.

These methods  simplify the conversion a little bit. For the example, see
\verb|ParamApplet.java| in line 11. But this method is only 
available to Integer, Long and Byte wrapper classes, NOT for
Float and Double as of Java 1.1. Fortunately they are included in the
Java 2 specification.
In the Java 1.1 case you have to use the \verb|valueOf(String s)| and
\verb|doubleValue(String s)|, \verb|floatValue(String s)| methods.

To convert a double value to a string you have to use the 
\verb|toString(double d)|
method, which is available for all primitive data types.
For example, two ways of doing it are:
\begin{lstlisting}{}
  double d = 3.1234;
  String s1 = Double.toString(d);    <------ most easy way
  String s2 = (new Double(d)).toString();
\end{lstlisting} 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Packages and Import Statements}
\subsection{Packages}
Because Java was designed to be able to load code distributed
over the whole internet dynamically, you have to avoid name conflicts
between the programs (classes). The Java solution 
for an Internet--wide unique naming scheme is to put
every class in a \emph{package}. A package  is a group of related
and possibly cooperating classes. The naming scheme is based on the
internet domain name of the organization at which the package is developed.

The name of the package is given
at the beginning of a file before the actual program (class)
definition starts. So for example if we put the statement
\begin{quotation}
  \verb/ package de.freiburg.simulation; / 
\end{quotation}
at the beginning of the ``Hello World'' application, we can compile
the application with \verb/javac HelloWorld_Application.java / like before.
But to run the application we have to use
\begin{quotation}
  \verb/ java de.freiburg.simulation.HelloWorld_Application / . 
\end{quotation}
You are wondering why the program does not start? It cannot, because
there is one more thing to know. Java is looking for programs (classes)
in the directory structure given by the package and the class name. So
for the example above you have to put the 
\verb/HelloWorld_Application.class/ file
in the directory \verb|de/freiburg/simulation/| and issue the command
in the directory, where the directory tree starts.

You could also use an environment variable called \verb|CLASSPATH|. It
describes the directories to search for the class files. So if the
\verb|CLASSPATH|-variable includes \verb|/home/user/java| you can
start the above example in this directory, if the class is in the 
subdirectory  \verb|de/freiburg/simulation/|. It has to be noted that
the entries in a \verb|CLASSPATH| specification may also be ZIP files
that contain these classes. On Unix systems the directories in a
\verb|CLASSPATH| specification are separated by `` :'' ( on Windows systems
by ``;'').


All the standard commands (classes) of Java are stored in a central jar
file, which is additionally packed to save disk space. These classes
are always searched, no matter the \verb|CLASSPATH|-variable is set to.

If you are not using the package command at all, Java uses the empty 
package. This means you can put your programs in the current directory.
This is not recommended for medium to complex programs, but for
test purposes and very small programs this is very convenient.

\subsection{The jar Tool}
If you have written a lot of small classes, which all work together
(called a project), you
can put them all inside a ``jar'' file and give the jar file
to friends instead of the whole bunch of small class files.
A jar file is just an archive created by the \verb|jar| program 
coming with the JDK. It works like the well-known UNIX \verb|tar|
command. This is actually a very nice method for packaging
applets on the internet, because the jar command also compresses
its contents. 

For example to view the contents of a jar file you can issue the command
\verb|jar tvf lava.jar|. The file \verb|lava.jar| is a file on the
CD ROM of the Lava Rocks package. You can use any other \verb|.jar| file
you have or can find anywhere. Some of the
available options used with jar are given in table \ref{tab:JarOptions}.
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{cp{0.7\textwidth}}
      Option & Description \\\hline
      c & create jar file\\
      t & table of contents of jar file\\
      x & extract files from jar archive\\
      f & name of jar file comes as first argument after options (the
          default is the standard input/output) \\
      v & verbose output \\
      O & do not compress (used for jars residing in the CLASSPATH)\\
    \end{tabular}
    \caption{Options of the jar command. The jar tool is included in the JDK.}
    \label{tab:JarOptions}
  \end{center}
\end{table}
Jar files are portable from one platform to the other, but as you can 
see jar is not as powerful as the tar command in UNIX.

\subsection{Basic Java Organization}
Java is basically defined in two ways: the first one is the basic
set of instructions, like all variables, all arithmetics and conditional
statements and loops (see in the next few sections). This is the
fundamental part of the language. 

The second one are the Application Programmers Interfaces (API).
They are just packages, which consist of many functions and variables
to provide a certain functionality. For example the applet API (package)
provides all the necessary functions to build and handle applets
in Java. 

The big difference to other languages like C for example, where also
certain (small) APIs exist, is that these APIs are all included
in the Java standard, including the ones giving access to graphical
capabilities. There is no place for different vendors to supply
different libraries (packages) for the same functionality, but
using different calling schemes and therefore making programs
non portable. 

\subsection{Import statement}
Before learning more about the syntax of Java, we have to explain another
statement appearing in the part of any Java program before the actual
definition of the class: the \verb|import|-statement. With \verb|import|
you can make classes available, so you don't have to use the fully
qualified name to the class, which would be very long sometimes. 

If you would like to
use the HelloWorld class from above in your programs, you have to change
the \verb|main()| method to let us say \verb|hello()|. 
\loadlisting{HelloWorld.java}{Listings_Java/HelloWorld.java}
Now you could either
type \verb|de.freiburg.simulation.HelloWorld.hello()| (the fully qualified 
name) in your program or you can use
\begin{sverbatim}
import de.freiburg.simulation.*;
....
   HelloWorld.hello();
\end{sverbatim}
to import all classes in the \verb|de.freiburg.simulation| class.
You can also use:
\begin{sverbatim}
import de.freiburg.simulation.HelloWorld;
....
   HelloWorld.hello();
\end{sverbatim}
if you just want to import one special class. But you can not use 
\verb|import de.freiburg.*;| and then call the method by using
\verb|simulation.HelloWorld.hello();|. You can not split the
package name in the import statement.

We have already made use of the \verb|import|-statement in the ``Hello World'' 
applet. There we have imported the \verb|java.applet|-class, which
defines applets and their behaviour, and the \verb|java.awt|-class, which
will be explained later.
 
There is one class, which is always imported without any import statement:
the \verb|java.lang.*| classes. This is the fundamental class of Java and it is
implicitly imported for all Java programs, so you do not have to specify
it. For example the System class is in \verb|java.lang|, that is why
we did not have to use an import statement in the ``Hello World''
application.  

%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Compiling Projects}
If you write a program consisting of many classes and files, you
may think that this is a lot of work to compile all of them. Or if
you are used to writing code in other languages, you might think
of using tools for checking if a program has to be recompiled, if you make
changes to some files. One of these tools might be the famous ``make''
utility. But fortunately this is not needed for Java, because
the JDK developers (or to be precise the Java standard) already
takes care of these problems. 

You have to arrange your code in the different classes according to 
certain rules (packages). So the directory structure is already a
nice tree structure of your project. 

If you then want to compile
the whole project, but only the files which have changed\footnote{Notice
that there is no dependence of classes on other classes in the
sense of re-compilation. Java does dynamical run-time linking and no static 
linking at the end of the compilation process as in all other languages.}
should be recompiled, you issue the
command 
\begin{sverbatim}
javac -depend -d base_directory main.java
\end{sverbatim}
then the Java compiler takes care of all ``dependencies''.   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simple Arithmetics, Conditional Statements and Loops}
\label{sec:Loops}

\subsection{Simple arithmetics}
As we already mentioned Java  supports almost all of the standard
C operators. The arithmetic operators that operate on numerical types
are 
\begin{center}
\begin{tabular}{ll}
$+$ & addition \\
$-$ & subtraction                 \\
$*$ & multiplication \\
$/$ & division \\
\% & remainder
\end{tabular}
\end{center}
The $+$ operator can also be used to concatenate strings, as we will
see later in an example in section \ref{sec:Parameter}.

It is important to remark, that in Java integer division truncates
toward zero (7/2=3, -7/2=-3 and -7/-2=3).

Java has two special operators for increment $++$ and decrement $--$. The 
expression \verb|i++| is equivalent to \verb|i=i+1| except that
\verb|i| is evaluated only once. They can be used as pre- and post-operators,
depending on the position of the symbols, e.g. \verb|i++| or \verb|++i|.
This does not make a difference, if you just have these statements
alone, but in some complex expressions this might make a difference.
The postfix (prefix) version of the operator ++ evaluates  the value
of the operand before (after) the increment operation.
For example \verb|i = j++| means setting i to j and then increment j by one.
But \verb|i = ++j| means setting i to j+1.

There is no power operator like \verb|**| in FORTRAN or \verb|^| like in many
different programs like TeX/LaTeX. In Java like in C/C++ you have to use
(like in C) the \verb|Math.pow()| method of the \verb|Math| class.
The \verb|^| operator, used sometimes for the power, is the exclusive
or (XOR) operation in Java (either in the logical or the boolean sense). 
We should not confuse this. 

Java supports also a standard set of relational and logical operators,
which all yield boolean values. They are listed below

\begin{center}
\begin{tabular}{ll}
$>$  & greater than \\
$>=$ & greater than or equal to \\
$<$  & less then \\
$<=$ & less than or equal to \\
$==$ & equal to \\
$!=$ & not equal to
\end{tabular}
\end{center}


The conditional operators
\begin{center}
\begin{tabular}{ll}
\& \& & conditional AND      \\
$\mid\mid$ & conditional OR
\end{tabular}
\end{center}
operate on  boolean expressions only.

Java has also bitwise operators which operate on integers and on
boolean types. They allow to perform bit manipulation on data.
\begin{center}
\begin{tabular}{lp{0.8\textwidth}}
\& & and \\
$\mid$ & or \\
$\tilde{}$ & not \\
$<<$ &  shifts bits left filling with zero bits on the right \\
$>>$ & shifts bits right filling with the highest sign bit on the
           left--hand side (like a division by 2)\\
$ >>>$ & shifts bits right filling with zero bits on the left--hand side, treating
    the argument as a bitfield
\end{tabular}
\end{center}
Some examples are in place
\begin{sverbatim}
 1 & 0   // is zero
 1 | 0   // is one
 ~10     // is -11, do it by hand to check
 2 << 1   // is 4, because bitwise is 2=0010 and 4=0100
 2 >> 1   // is 1, because bitwise is 2=0010 and 1=0001
 2 >>> 1  // is also 1, like above
 2 >> 3   // is 0, because bitwise is 2=0010 and 1=0000
\end{sverbatim}
You can use these operators for doing fast divisions by powers by $2$, 
because it is much
faster to do a bitshift than a division. For example, instead of
writing \verb|16/2| use \verb|16 >> 1| or instead of using \verb|8/4|
we can write \verb|8 >> 2|. 

Last not least we have to mention the fundamental assignment operator
$=$. It may be used in combination with other operators, e.g., $+=$
means is incremented by.


\subsection{Loops}
\paragraph{for Loops}
For our forthcoming applications the most important control statement
is the \verb|for| statement. It is used to loop over a range of values
from the beginning to the end. Its syntax is
\begin{sverbatim}
for (init_expressions; boolean_expr; incr_expressions) {
    statements
}
\end{sverbatim}
where \verb|init_expressions| denotes the initial value of the iterated
variable, \verb|incr_expressions| denotes the increment of the iterated
variable. For both you can specify more than one expression separated
by commas (as in C). This is the only place, where you can use these comma
separated lists. The variables used in the for statement can be 
integer (long) or float (double) values. 

At the beginning of the \verb|for| loop the boolean expression
\verb|boolean_expr| is evaluated. If its value is found to be 
\verb|true| the statement is executed repeatedly with increment
\verb|incr_expr| until the value of the boolean expression is found to
be \verb|false|.

As an example demonstrating the use of
\verb|for| loops we want to write a program to calculate the mean of
a given number of random numbers. One possible implementation
could look like this:
\inputlisting{Listings_Java/DataMean.java}

Here we used the class \verb|java.util.Random| which allows for
the creation of random numbers. If we don't supply a seed, as is the
case here, it just uses the time to initialize the generator. The
initialization takes place in line 10, where a new generator is created.
You can check this by running the application more than once and comparing
the means -- they should not be the same. 

The \verb|next.Double()| method returns a new random number of type
double (for a float use \verb|rand.nextFloat()|). You can also create normally 
distributed random numbers with the \verb|nextGaussian()| method of
the \verb|Random| class.
The remaining parts of the program should be self explaining. You can of
course use any expression (e.g. \verb|d=d*u+2|) 
in the last part of the for statement, not only
the \verb|++| operator, which is obviously used most often. 

\paragraph{Byte-Code of a class file}
Using the \verb|DataMean()| program, we want to show the byte-code
produced by the Java compiler. In the first line you can see the
command to use (\verb|javap|) and below the output:
\begin{scriptsize}
\begin{verbatim}
Command_Line>>> javap -c DataMean

Compiled from DataMean.java
public synchronized class DataMean extends java.lang.Object
    /* ACC_SUPER bit set */
{
    public static void main(java.lang.String[]);
    public DataMean();
}

Method void main(java.lang.String[])
   0 sipush 10000
   3 istore_3
   4 new #10 <Class java.util.Random>
   7 dup
   8 invokespecial #12 <Method java.util.Random()>
  11 astore_1
  12 dconst_0
  13 dstore 4
  15 iconst_1
  16 istore_2
  17 goto 32
  20 dload 4
  22 aload_1
  23 invokevirtual #17 <Method double nextDouble()>
  26 dadd
  27 dstore 4
  29 iinc 2 1
  32 iload_2
  33 iload_3
  34 if_icmplt 20
  37 dload 4
  39 iload_3
  40 i2d      
  41 ddiv
  42 dstore 4
  44 getstatic #18 <Field java.io.PrintStream out>
  47 new #8 <Class java.lang.StringBuffer>
  50 dup
  51 ldc #2 <String " The mean of ">
  53 invokespecial #13 <Method java.lang.StringBuffer(java.lang.String)>
  56 iload_3
  57 invokevirtual #15 <Method java.lang.StringBuffer append(int)>
  60 ldc #4 <String " random numbers
">
  62 invokevirtual #16 <Method java.lang.StringBuffer append(java.lang.String)>
  65 ldc #3 <String " between 0 and 1 is ">
  67 invokevirtual #16 <Method java.lang.StringBuffer append(java.lang.String)>
  70 dload 4
  72 invokevirtual #14 <Method java.lang.StringBuffer append(double)>
  75 ldc #1 <String " !">
  77 invokevirtual #16 <Method java.lang.StringBuffer append(java.lang.String)>
  80 invokevirtual #20 <Method java.lang.String toString()>
  83 invokevirtual #19 <Method void println(java.lang.String)>
  86 return

Method DataMean()
   0 aload_0
   1 invokespecial #11 <Method java.lang.Object()>
   4 return
\end{verbatim}
\end{scriptsize}

\paragraph{while and do--while}
Java offers also the possibility to use other loop constructs, the
\verb|while| and the \verb|do-while| loop. There syntax is
\begin{sverbatim}
while (boolean_expression)
 statement
\end{sverbatim}
and
\begin{sverbatim}
do
  statement
while (boolean_expression)
\end{sverbatim}
It is important to observe that in the first construct the boolean
expression is evaluated \textit{before} the statement is executed, while in
the second construct the boolean expression is evaluated \textit{after} the
statement has been performed!

In order to give an example we write down an equivalent code using
the
\verb|while| statement of the \verb|for| loop of the
\verb|DataMean.java| program. Lines 13 to 15 have to be replaced by
\begin{sverbatim}
int i;
while(i<N){
  mean += rand.nextDouble();
  i++;
}
\end{sverbatim}

\subsection{Conditional Statements}
\paragraph{if-else}
The \verb|if| statement is the fundamental form of conditional control
of flow. It allows to choose, whether the statements that follow it are
executed or not. Its syntax in Java is
\begin{sverbatim}
if (boolean_expression) {
   statement1
}
else if (boolean_expression) {
   statement2
}
else {
   statement3
}
\end{sverbatim}
First, the boolean expression is executed. If the value is \verb|true|
then \verb|statement1| is performed, otherwise if there is the
optional \verb|else| statement \verb|statement2| is executed. Of
course, \verb|if-else| constructions can be nested, i.e., an
\verb|if-else| conditional control flow, can be placed within another
\verb|if-else| statement.

\paragraph{The conditional operator ?} The conditional operator ?
provides a single expression yielding one of two alternatives depending on
a boolean expression. To demonstrate its use we write down an
\verb|if/else| Java code first and translate it into an equivalent  ? 
construction. The \verb|if/else| code reads

\begin{sverbatim}
if (a<b) 
  x=1.0;
else
  x=2.0;
\end{sverbatim}
The equivalent construction with the conditional operator ? is more
compact
\begin{sverbatim}
x= (a<b ? 1.0 : 2.0);
\end{sverbatim}
The meaning of the different expressions in the above statement should
be obvious.


\paragraph{(labelled) break and continue -- goto}
We already remarked that Java does not have a \verb|goto| instruction
to transfer control to an arbitrary statement in a method. To handle
with situations where other languages have a \verb|goto| Java provides
the labelled \verb|break| and \verb|continue| statements. Labels are
typically used in blocks and loops and precede statements
\begin{sverbatim}
label: statement
\end{sverbatim}
The \verb|break| statement is used to exit from a block, e.g. to break
out of a loop. E.g., an unlabeled \verb|break| terminates the innermost
\verb|for|, \verb|while| or \verb|do|.

The \verb|continue| statement is used only within loops. It skips to
the end of the loops body and evaluates the boolean expression that
controls the loop. The \verb|return| statement terminates execution of
a method and returns to the invoker. If a method returns no value you
can use (you can also just omit it)
\begin{sverbatim}
return;
\end{sverbatim}
if the method has a return type, the \verb|return| must include an
expression for a returned type. You can use as many return statements 
as you like, but only one is executed each time the method gets called.

\paragraph{recursive programming}
As in most other languages, recursive programming is allowed, although
it should be avoided. First because of the clarity of the code
and second it has low performance and larger memory consumption. 
Therefore we do not see any reason to show an example, just
avoid using recursive algorithms.

\paragraph{switch/case}

Another central flow structure is the \verb|switch| statement. It
evaluates an integer expression whose value is used to find an
appropriate \verb|case| label among those listed inside the following
block. The \verb|switch| statement may be used to replace nested \verb|if-else|
statements that determine what is the output for each number. The
\verb|switch| statement works only if the value being tested is a
primitive integral type and when the value is tested against constant
values. the basic syntax of the \verb|switch| statement is
\begin{sverbatim}
switch(expression) {
    statements
}
\end{sverbatim}
After evaluating the expression, the switch statement executes
certain code within the block depending on the integral value of the
expression. This information is indicated by the integer label following
the \verb|case:| statement. If there is no \verb|case:| label that
matches the value of the expression, the \verb|swich| command executes
the code following \verb|default:|, if there is one. Otherwise,
\verb|switch| does nothing.

An example of the use of the \verb|switch| statement is found in the
simple program \verb|DiceGame.java| 

\inputlisting{Listings_Java/DiceGame.java}

Again we want to stress that only an integer, long, char or byte type
is possible in the switch statement (no double or float). And the
case expressions have to be integral values and not any boolean
expressions like \verb|i>2|. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Arrays, Matrices and Strings}
\label{sec:Arrays}

Before discussing the notion of classes and objects, we want to introduce
another reference type: the array. Arrays are actually objects
(see Chapter \ref{sec:objectoriented}), but
Java provides many special commands for arrays, which makes them a 
little bit special.

The first question is how to create arrays and how to destroy them.
The destruction is easy to explain: it is done automatically
by the garbage collector (like for all objects). This is different to
other languages like C, C++ and Fortran 90, where you explicitly
have to destroy (free) the allocated memory. 
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{c|c|c|c|c}
      F77 & F90 & C & C++ & \textbf{Java} \\\hline
      -- & allocate & malloc & new & new \\
      -- & deallocate & free & dispose & -- \\
      -- & Pointer & \multicolumn{2}{c|}{Pointer} & References + Garbage Collector \\
      -- & -- & \multicolumn{2}{c|}{Pointer arithmetic possible}& there is no 
                                                    reference arithmetic \\
    \end{tabular}
    \caption{A comparison of the different memory allocation commands in different languages.}
    \label{tab:MemoryAllocation}
  \end{center}
\end{table}
To create an array you have to use the \verb|new| keyword used for
creating (instantiating) objects. So to create a one dimensional
array, called \verb|intarray|, with 10 elements you use:
\begin{sverbatim}
        int intarray[] = new int[10];
\end{sverbatim}
This also sets all the elements to zero. But this is only true for 
primitive types. Arrays of reference types (objects) are created the
same way, but the elements consist of references to the elements. The
elements themselves are NOT initialized and have to be created too.
An example for this is a two dimensional array as we will see soon.

Indices of arrays in Java start with zero as in C and not with 1
as in Fortran. No negative indices are allowed in Java. This is the 
reason for numbering the chapters in this book starting from $0$.
The length
of an array (meaning the number of elements) is always given
by the \verb|.length| field. For the array above you get the number
of elements by using \verb|intarray.length|. We have already met
this notation when we discussed the command line parameters.

You can also create the array and initialize it right away by using
(also in Java 1.0):
\begin{sverbatim}
  int intarray[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int[] intarray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
\end{sverbatim}
or one step further, create an array of objects (here strings) and
create the elements in the same step:
\begin{sverbatim}
  String stringarray[] = {"a","b","c","d","e","f","g"};
\end{sverbatim}
In Java you can even put the brackets behind the type instead of the
variable name (not possible in C). So it does not matter if you
write \verb|int intarray[];| or \verb|int[] intarray;|.

In Java 1.1 you can also use \emph{anonymous arrays}:
\begin{sverbatim}
  String[] texts;
  texts = new String[] {"a","b","c","d","e","f","g"};
  System.out.println(new char[] {'h','e','l','l','o'});
\end{sverbatim}
So you can create and initialize arrays without even using a variable.

Multidimensional arrays are also supported. Just like in C they are
arrays of arrays. For example
\begin{sverbatim}
  double matrix[][] = new double[10][10]; 
\end{sverbatim}
creates a 10 by 10 matrix, called \verb|matrix|, 
meaning that you have created 10 arrays
of type \verb|double[10]|. An important point to make is that you
do not have to specify all dimensions at once. You can for example
create a triangular matrix by submitting:
\begin{sverbatim}
  double matrix[][] = new double[10][];
  for (int i=0; i<10; i++) {
         matrix[i] = new double[i+1];
  } 
\end{sverbatim}
To access multidimensional arrays you can also use one dimensional
array syntax (as in C). If you have a two dimensional array 
you can access the element [i,j] by accessing the element [i+j*columns]. 

Now let's look at an example using arrays. We have rewritten the program
\verb|DataMean| above to calculate the average of random 
numbers by using arrays.

\loadlisting{DataMeanArray.java}{Listings_Java/DataMeanArray.java}

Here we first declare a double array called \verb|RandomNumber| and
create it in Line 13. Then we store the random numbers in the array
and afterwards calculate the mean.
The last important point to address is the copying of arrays. 
You can not just write
\begin{sverbatim}
  int[] array1 = {1,2,3,4,5};
  int[] array2;
  array2 = array1;          // WRONG ! - ERROR ! 
\end{sverbatim}
This would only copy the reference of the array1 object to the array2
object, not the values, the memory address is the same. 
To copy the values of arrays you have to use the 
\verb|arraycopy()| method of the java.lang.System class. 
So to copy an array in the above example, you have to write:
\begin{sverbatim}
  System.arraycopy(array1,0,array2,0,array1.length);
\end{sverbatim}
This copies all elements of array1 to array2 staring from element 0. 
The remaining parts of array2 are not created!

\subsection{Arrays in Java 2}
A new class \verb|Arrays| in the \verb|java.util| package has been
introduced in Java 2, which is of great interest not only to scientific
programmers. It includes methods for sorting arrays of arbitrary
type using an improved version of the Quick-sort\footnote{This is
a sorting algorithm, which is very versatile and efficient for
most datasets. For details see \cite[]{bentley:93}} 
algorithm. So to sort a whole array  
of double values into ascending numerical order, you just have to use
\begin{sverbatim}
  /* JAVA 2 */
  import java.util.*;
  double[] array = new double[1000];
  ....
  Arrays.sort(array,0,1000); // to sort the whole array
\end{sverbatim}
You can even sort an array of strings or arbitrary objects,
although the algorithm used for the object sorting is allowed to 
vary from one
implementation of the virtual machine to another.


Another new functionality is the \verb|fill()| method. Often you
want to assign a value to a whole array of doubles for example.
In Java 2 you can do this using
\begin{sverbatim}
  /* JAVA 2 */
  import java.util.*;
  double[] array = new double[1000];
  Arrays.fill(array,1.0);
\end{sverbatim}
which sets the whole array to 1.

Furthermore there is a comparison method for arrays called
\begin{sverbatim}
Arrays.equals(double[], double[])
\end{sverbatim}
for all data types and
last but not least there is a binary search algorithm to
find a value in an (sorted) array. So for example to find the index of the
array element equal to 2.5 you can use the code:
\begin{sverbatim}
  /* JAVA 2 */
  import java.util.*;
  double[] array = new double[1000];
  ....
  Arrays.sort(array);
  int index = Arrays.binarysearch( array, 2.5 );
\end{sverbatim}

\section{Parameters from the Command Line or a HTML File}
\label{sec:Parameter}

%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Parameters from the command line}
The access of parameters given on the command line is as easy as it
is in C and C++. The parameters are stored as strings in Java and
are given as the parameters to the main() method of the application.
That is the reason for the Syntax:
\begin{quotation}
  \verb|public void main(String[] args) |
\end{quotation}
It means that the array \verb|args| contains the parameters. Each parameter
is separated with a space in the command line. Here is an example of a 
program using command line parameters:
\loadlisting{ParamCommandLine.java}{Listings_Java/ParamCommandLine.java}
So if you run the program as \verb|java ParamCommandLine 12 34 abcd t5|
the output on the screen will be
\begin{sverbatim}
 Parameter No. 0 : 12
 Parameter No. 1 : 34
 Parameter No. 2 : abcd
 Parameter No. 3 : t5
\end{sverbatim}
and if you don't supply parameters it will be
\begin{sverbatim}
 NO parameters specified !
\end{sverbatim}
We also see the concatenation of strings in the output statement.
And because you can only supply one argument to the  \verb|println()|
method, you have to concatenate all outputs to one long string.

\subsection{Parameters from a HTML file}
In applets there is no command line to supply parameters. 
So, in order to transmit 
parameters from the calling HTML file to the Java applet we have to
proceed in a different way.
In the HTML file you can
specify \verb|<PARAM>| attributes.
\loadlisting{ParamApplet.html}{Listings_Java/ParamApplet.html}

In this case we supply two parameters, called \verb|NumberofPoints| and
\verb|DisplayText| to the Java applet. The value is given in the string
behind the keyword \verb|value|. The Java applet to this HTML file
could look like this:
\inputlisting{Listings_Java/ParamApplet.java}

In the \verb|init()| method we get the parameter \verb|NumberofPoints|
and convert it to an integer using a wrapper method. The string 
of the parameter \verb|DisplayText| doesn't have
to be converted. Then in the \verb|paint()| method we display
the transmitted parameters on the screen. The output in the 
appletviewer or in Netscape should look like this:
\begin{sverbatim}
  Parameter NumberofPoints is 10000

  Parameter DisplayText is "This_is_a_test_parameter!"
\end{sverbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{peter}
\bibliography{V_98,simulit}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "V_98"
%%% End: 
