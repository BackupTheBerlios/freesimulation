\chapter{Object Oriented Programming and Advanced Java Features}
\label{sec:objectoriented}

The biggest step you have to take in mastering Java if you are
coming from the Fortran or C community, is to switch to the object
oriented paradigm. Although C++ programmers are used to objects, there
are quite a number of differences to C++ in Java. That is why Java
is closer to C than to C++. Since the notions of classes, objects, and
methods are quite abstract we want to introduce them with the help of
a few examples. First we discuss a classical example from probability theory,
the Buffon needle problem. Then we write a random number 
generator, and last we write a class for calculating 
statistical properties of an double array.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A Classical Example: The Buffon Needle}

It seems that the earliest documented application of stochastic simulation
methods to the solution of an integral has been advanced by Comte de
Buffon \footnote{Georges Loui Leclerc Comte de Buffon ($^*$ Montbard
  (Dijon) 7. 9. 1707, \dag Paris 16. 4. 1788). He was director of the
  Jardin des Plants in Paris and since 1753 member of the Acad\'emie 
fran\c{c}aise. His  work ``Histoire naturelle'', in which theories
about the origin of the earth and of  its organisms aare discussed,
was one of the most famous and translated works of the Age of
Enlightment. Influenced by I. Newton he sustained the scientific
method based on observation and experiment. His work contains many
ideas which entered furure scientific theories.}. The famous Buffon
needle problem has been formulated in 1733 but published only in 1777. It is
supposed
to be the first experiment, a kind of analogue simulation, in the
context of geometric probabilities. The problem can be stated in the
following way: A needle of length $L$ ($L=2l$) is drawn at random onto a
horizontal plane ruled with straight parallel lines. The distance
between the lines is $D$ ($D \ge L$; $D=2d$). 
What is the probability $P$ that the
needle will intersect one of these lines?

In fact Comte de Buffon performed the experiment of throwing the
needles many times to determine the probability $P$. He also carried
out the mathematical analysis of the problem which we want to review
shortly.

For convenience we denote by $x$ the distance of the middle point of
the needle to the nearest line and by $\phi$ ($0 \le \phi \le \pi$) the
angle between the needle and this line (see
Fig. (\ref{buffondefinition})). The quantities $x$ and $\phi$
completely determine the position of the needle. It is evident from
Fig. (\ref{buffondefinition}) that the needle crosses the line only if
the condition
\begin{equation}
\label{buffoncondition}
x \le l \sin \phi
\end{equation}
is satisfied.

\begin{figure}
\label{buffondefinition}
\includegraphics[width=.7\textwidth]{Figures/buffondefinition.eps}
\caption{The Buffon needle problem. Definition of the variables $x$
  and $\phi$.}
\end{figure}

Let us look at the possible positions of the needle in the $x$--$\phi$
plane (see Fig. (\ref{buffonplane})). All positions lying below the
$l\sin \phi$ curve between the abscissa 0 and $\pi$ satisfy the
condition (\ref{buffoncondition}). The surface of this region is
immediately found by integration, $F=2l$. The surface $F$ is a measure
for the set of all positions of the needle which cross one line. On
the other side it is clear that $\pi d$ is am measure for the surface
of all possible positions of the half needle. The ratio of the two
measures $ 2l/\pi d$ is the probability we were looking for, i.e.,
\begin{equation}
\label{buffonprobability}
P = \frac{2 l}{\pi d}.
\end{equation}

\begin{figure}
\label{buffonplane}
\includegraphics[width=.8\textwidth]{Figures/buffonplane.eps}
\caption{The Buffon needle problem. The $x$--$\phi$ plane (schematically).}
\end{figure}

Some years later (??) Laplace 
\footnote{Pierre Simon Marquis de Laplace, $\ast$ Beaumont--en--Auge
  28.3.1749 \dag 5.3.1827 Paris. Laplace was one of the leading french
  mathematicians of his time. Before being a member in the Acad\'emie
  des sciences and a Professor at the \'Ecole Normale in Paris (1794)
he was an examinator at the \'Ecole militaire in Paris, where in 1785
he examined Naplo\'eon Bonaparte. The most important contributions of
Laplace where in celestial mechanics, cosmology, mathematical physics
and, probability theory. In his work ``Th\'eotie analytique des
probabilit\'es'' (1812) he develops  for the first time a systematic
mathematical treatment of probabilistic problems.} recognized that
the idea behind the Buffon needle experiment could be used to evaluate
$\pi$ from the throws of the needles. Today we would call this a
Monte Carlo determination of $\pi$. If we repeat the experiment $N$
times and count the number of times the needle crosses a line $M$, the
probability $P$ can be estimated by the relative frequency of hits
\begin{equation}
\label{buffonestimateP}
P \approx M/N
\end{equation}
and hence we have with Eq. (\ref{buffonprobability})
\begin{equation}
\pi \approx \frac{2lN}{dM}
\end{equation}
Now, let us try to write a Java code for the simulation of the Buffon
needle problem.

\subsection{The Traditional (Procedural) Approach}
The traditional approach is straightforward. You just
draw \verb|N| needles and check each needle if it crosses a
line or not. So there are two subroutines. One creates a new
needle with all four coordinates. And the second one is a 
routine, which just compares the lines with the needle coordinates,
whether it crosses the lines or not. You then count the number
of crossings and you get the final estimate of Pi.
\loadlisting{BuffonProcedural.java}{Listings_Java/BuffonProcedural.java}

First of all we have made use of the \verb|Math.random()| method, which
draws a random number (a double) between 0 and 1. We also used arrays
to store the coordinates and even used arrays as parameters to
subroutines (methods). The remaining of the program should be
self-explaining.

\subsection{The Object Oriented Approach - Classes and Objects}
\label{sec:Classes_and_Objects}
Before we begin to write the object oriented code 
we have to introduce some formal aspects of the Java language.

\subsubsection{Definition of Objects}
We have already met a lot of object oriented features 
without discussing them in detail.  For example, we already noticed
that the fundamental unit of programming in Java is the {\em class}. A
concise definition of classes and objects in Java could be:
\begin{quote}
A class is a collection of data and methods that operate on that data. In
Fortran or C we call the methods procedures or functions. An object
is an instance of the class, meaning it is a thing to work with. The class
defines the data necessary for the object and the functions which can
operate on them.   
\end{quote}

In other words, like in other languages you can compute only with
primitive types (integer, float, ...) but you can also create and
manipulate objects. An example already familiar to us, is the  array. 
If you have an array 
object you can call the method \verb|length| to get the number of
elements of the array. 

So what is the difference to the standard function approach here?
Instead of using function arguments you supply the argument by 
putting them in front of the method separated by a point, e.g., 
\verb|args.length|. The missing brackets on the \verb|length| method
is not a miss-print, the Java engineers thought it might ease writing
array code, but actually it confuses sometimes. Still it is the
most easy demonstration of calling a method of a class.

To calculate the mean of an array of doubles, you can
either write a method which takes the array as an argument (like you would
in Fortran or C) or you can use the object
oriented feature:
\begin{small}
\begin{verbatim}
        double[] array = new double[100]; 
\end{verbatim}

\begin{minipage}{.47\textwidth}
\textbf{Functions}
\begin{verbatim}

  result = mean(array); 
\end{verbatim}
\end{minipage}
\begin{minipage}{.47\textwidth}
\textbf{Object Oriented}
\begin{verbatim}
  Data dat = new Data(array); 
  result = dat.mean();
\end{verbatim}
\end{minipage}
\end{small}
\vspace{.2cm}

\noindent Look at the third example in this chapter, which demonstrates these two
possibilities in detail.

It is up to you, which version you prefer. But because all programs are
actually classes in Java you have to understand at least the 
most fundamental things about object oriented programming. For a detailed
discussion and introduction, see \cite{javanutshell}.

Just to remind you again, strings are objects and not primitive 
types. To use strings you first have to declare and instantiate a string
object. Here are three possible ways of doing it:
\begin{verbatim}
        String text;
        text = "Test String";
        text = new String();
        text = new String("Test String");
\end{verbatim}
The first line only declares a string object called text and does not
allocate (instantiate) the memory for the value of the object, just
the reference to the value. The second line instantiates and 
defines the String object \verb|text|. The third line instantiates, but
does not define it and the fourth line is like the second line, with
the second line being more efficient in memory consumption and
speed.

An important example of calling methods of classes or objects is
the \verb|.length()| method of the \verb|String| class. In contrast
to the \verb|length| method for the arrays, we have to write the
brackets this time. For example the length of a string can
be printed by using
\begin{sverbatim}
   String s = "text test";
   System.out.println("The length is:"+s.length());
\end{sverbatim}
And if you want to convert the letters of a string to lower case,
you can use the \verb|toLowerCase()| method, e.g.
\begin{sverbatim}
   String s = "TEST Text";
   System.out.println("in lower case letters :"+s.toLowerCase());
\end{sverbatim}


\subsubsection{The Code of the Object Oriented Approach}
Now we want to
write a Java code which allows the simulation of the Buffon needle
problem. It is clear that in the problem at hand ``needles'' will play
a central role. Each needle may be described by the $x$-- and
$y$--coordinates of  its two ends. Of course, for each needle we can
check whether it crosses a line or not. We draw needles at random so
different needles will have different coordinates. However, needles
have also generic properties which justify to define needles as a class!

The listing of the \verb|Needle| class can be seen below. We are going
to explain basic concepts while discussing this example.
\lstinputlisting{Listings_Java/Needle.java}

\subsubsection{Class variables, Constants and Modifiers}
The needle class has four fields which correspond to the four
coordinates which specify the position of the needle. 
The term fields is used in Java as a synonym for variables.
Furthermore, we
need some specification for the geometry involved in the problem.
Some of the fields  are
defined with the \verb|final| keyword. This is the equivalent to the
const keyword in C. A final field can not be changed anymore.

There is a nice feature to be used with the final keyword. You can
define a final variable, actually computed in an arbitrary method. 
The method is then executed before any other code of the program,
even before the main method. An example would be:
\lstinputlisting[first=12]{Listings_Java/TestFinal.java}
 
The variable \verb|cross| is declared to be \verb|static|.  This
modifier 
defines a field (variable), which is belonging
to the class and not to the object. So every object of that class 
has the same value for a \verb|static| field. The \verb|public| modifier
on the other hand defines a field or method, which is special to 
an object not to the class -- this is also called an instance field or
method, the \verb|static| version is called a class variable or
method.

In Table \ref{tab:modifiers} we give an overview of some available modifiers.
\begin{table}[htbp]
  \begin{center}
    \leavevmode
    \begin{tabular}{l|p{8cm}}
     Modifiers &                                 \\ \hline \hline
     final & variables may not be changed, methods can not be overwritten,
             classes may not be subclassed\\\hline
     public & accessible from anywhere\\ \hline
     static & defines a top-level class, a class variable (field) or 
                 a class method\\\hline
     private & only within the defining class visible, not in other 
               packages, even if subclass of this class\\\hline
     protected & accessible within the package in which it is defined and
                 within subclasses\\\hline
     (none) & accessible only in its package\\
    \end{tabular}
    \caption{Overview of some available modifiers in Java, see also figure
      \ref{fig:ModifiersGraphics}For a complete
      overview take a look at page 230-234 in \cite{javanutshell}.}
    \label{tab:modifiers}
  \end{center}
\end{table}
A graphical representation of the access control of variables and
objects is in figure \ref{fig:ModifiersGraphics}.
\begin{figure}[htbp]
  \begin{center}
    \includegraphics[width=.7\textwidth]{Figures/ModifiersGraphics.eps}
    \caption{A graphical overview of the access control of variables and objects/classes in Java.}
    \label{fig:ModifiersGraphics}
  \end{center}
\end{figure}

It is important to remark that
class variables and methods are the closest relatives to global 
variables in all the other languages. They are accessible from all
classes, but still are belonging to a class. So you could have two
class methods with the same name, but for different classes.

Having fixed also some constants, e.g. $\pi$ and the distance between
parallel lines, we have to initialize the class. This is done by means
of the constructor.

\subsubsection{The Constructor}
An important part of any class is the constructor of the class. This is
the method (function), which is called when an object of this
class is instantiated. It always has the same name as the class itself.
The constructor can have zero or more arguments and you can even
have different constructors depending on the parameters provided by
the calling syntax.

The constructor of a class ALWAYS calls the constructor of its
superclass, so it is good practice to write \verb|super();| at the
beginning of a constructor to indicate this feature. Because the 
constructor of the super class also calls the constructor of its super
class again, this is called ``Constructor Chaining''.

In our example a needle is initialized in the following way. We draw
at random the four coordinates \verb|needleX1|, \verb|needleX2|,
\verb|needleY1|, and \verb|needleY2| which determine the position of
the first needle. Note, that we have made use of the keyword
\verb|this|.
This keyword is always required when the argument of a method
or a local variable in a method have the same name as one of the fields
in the class. If the method is simple, as it is the case here, it is
not necessary to be that careful.

Here in our example, the constructor just sets the four coordinates
and does not need any parameters to instantiate the needle.

\subsubsection{Methods and Class Methods}
Having initialized the class we now want to define some methods in our
\verb|Needle| class. There is only one method in our class, which
is the \verb|crossinspection()| method.
The return type of methods always has to be specified, if
there is no return value you have to use the \verb|void| statement
(as in C). The value to be returned is specified by the return keyword.

The method \verb|crossInspection| checks whether
a needle crosses a line or not. The \verb|crossInspection| method
returns a boolean telling you, if the needle crosses a line or not.
Note that the variable \verb|cross| has
been defined as a class variable with the help of the modifier \verb|static|
and gets incremented every time you check a needle, which crosses a line.
With this method our \verb|Needle| class is complete.

Next we need to look at the class \verb|Buffon.java| which contains the
\verb|main| method and demonstrates how to use the \verb|Needle| class.
\loadlisting{Buffon.java}{Listings_Java/Buffon.java}

By defining the \verb|Needle| class in Java, we have created a new
data type. Variables of this type can be declared by
\begin{verbatim}
Needle draw;
\end{verbatim}
\verb|draw| is simply a name that refers to a \verb|Needle|
object (references the object). 
Creating dynamically an object
is done with the help of the \verb|new| keyword
\begin{verbatim}
draw = new Needle();
\end{verbatim}
Next, in a \verb|for| loop we draw \verb|N|  needles and with the help
of the \verb|crossInspection| method we check whether the needles
cross the lines or not and the class variable \verb|cross| is set
accordingly. Finally, the result, i.e. the estimated value
for $\pi$ is printed.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A Random Number Generator}
Since the concepts we just introduced are quite abstract it may be
useful to see them in action with the help of a second example.
So let us write a class, which calculates random numbers uniformly
distributed between 0 and 1. To this end we write a class
\verb|RandomNumber|. It has three fields (variables), two of them are
defined with the \verb|final| keyword.
\inputlisting{Listings_Java/RandomNumber.java}
In our example, we just set the seed in the constructor and as 
you can see you have to supply the seed, when you instantiate the
generator. Most of the constructors don't even need a parameter to 
instantiate the object. 

In the program we have made use of the \verb|Math.pow()| method, 
which is defined in the \verb|Math| class of the standard
Java API \verb|java.lang| and it computes the power of the first
argument to the second one (see section \ref{sec:Standard_Math}).

Additionally we have included some routines to show how
private variables can be handled. Because there is no
way for programs to access the fields of the class from
the outside of this class, you have to supply methods to read
or write the fields. This is actually the way you have to write
Java beans discussed shortly in section \ref{sec:Beans}.

Then the method \verb|nextRand()| is defined and returns the next
random number calculated using a congruential method\footnote{See later 
in this book for details about how to generate random numbers.}. 

Now we have to write a program (class), which uses this class to 
calculate the average of some random numbers.
\inputlisting{Listings_Java/UseRandomNumber.java}
The class is called \verb|UseRandomNumber| and just contains the
main method. First we instantiate (create) an object of class
\verb|RandomNumber|. Then we create an array and in a loop we
create \verb|N| random numbers using the \verb|nextRand()| method
of our class applied to the object we just created. The remaining
part has already been explained.

Remember that we have to put both programs in one directory called
\verb|simu|, because we have used the \verb|package| command. Here it
was just to get you acquainted with these terms.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Calculating Moments}
A third example demonstrates how to create a class for calculating
some statistical measures for data sets. Here we show the
different approaches of programming models in Java. 
You have basically three choices:
\begin{enumerate}
\item You can use the ``program in one file'' approach: 
\lstinputlisting{Listings_Java/Moments_all.java}
\item You can use the ``traditional procedural'' approach:
\lstinputlisting[first=23,last=28]{Listings_Java/Moments_procedural.java}
\lstinputlisting[first=35,last=42]{Listings_Java/Moments_procedural.java}
\item You can use an object oriented approach, the first class is
  the main program using our own class and the second one is the
  code for the data class itself. We have written two different 
  versions to show the difference between a class method and 
  an object method.
  \lstinputlisting{Listings_Java/MomentsData.java}
  \lstinputlisting{Listings_Java/Moments_object.java}
\end{enumerate}

%%%%%%%%%%%%%%%%%
\subsection{Interfaces and Abstract Classes}
Abstract classes/methods 
are also special classes, which can not be instantiated
and contain no code for the (abstract) methods. If you define
some methods, which contain no code as abstract, you have to 
define the whole class as abstract. You can subclass from an 
abstract class and override the abstract methods. You do not have
to override all abstract methods, but then the subclass is abstract
too.

An even more important concept in Java is the interface.
An interface is basically a(n abstract) class, which does not implement 
all the
methods defined in the class. All methods have automatically the public
modifier and are abstract.
Therefore you can create classes defining abstract methods,
which should be implemented (maybe system dependent, e.g. if you use
the native modifier) somewhere else. Interfaces can be subclassed
to create new interfaces.

Most of the GUI classes of the AWT introduced later are
actually interfaces or abstract classes and not just ordinary classes.
Very useful is this concept for passing methods as arguments to
other methods (see section \ref{sec:PassingArguments}).


%%%%%%%%%%%%%%%%%%
\subsection{Extending (Inheritance) and Overloading (Overriding) Classes}
Often you want to define subclasses, which should inherit all
the methods and fields from another class. This is easily done
in Java by extending a given class. The meaning of sub-classing is the
notion of data hiding or encapsulation. For example you can write
a subclass, which can not access all the variables of the super class,
therefore hiding some details. 

You can reference the super (parent) class by applying the
\verb|super| modifier in front of a method or variable of
the parent class. And the \verb|this| modifier always refers to
the actual class. 

You can also have equal names for a variable in the super class and the
child class, which means you have to reference the variables explicitly
by using the \verb|super| or \verb|this| keywords. If you want to refer
to a variable two classes up from the actual class, you have to use
the notion of ``shadowing'' \cite[]{javanutshell}, which is a kind of
casting with classes. 

If you define a class to be final, it can not be extended.
For example the java.lang.System class is a final class.

Different from C++,  you can not inherit from more than one class
in Java, meaning that there is always only one superclass for each
class. 
The only way of having multiple inheritance is by using
interfaces, which we will not cover extensively in our introduction.

If you write a subclass you can overwrite methods already defined
in the super class. This is called overloading of methods,
analogous to the C++ overloading. But in C++ you can even
overload operators like +, -, etc., which is not possible (in Java 1.1) yet.

A simple example is given by the
HelloWorld\_Applet.java program in section \ref{sec:Applet}.
There we have extended the Applet class of the Java.applet package
and therefore making our program a subclass of the Applet class.
So we inherited all the methods and fields of that class. Then we
overloaded the \verb|paint()| method to display our message. 
In the words of object oriented programming, writing an applet is
called: defining a subclass of the Applet class and overloading
the methods of the Applet class as necessary.

One nice and important feature in Java is, that all classes which
do not have an explicit parent, inherit from the \verb|java.lang.Object| 
class. So you can call this class the father of all classes.
There are only a few methods defined in this (abstract) class,
which you can always override. For example the \verb|toString()| 
method is in \verb|java.lang.Object|. If you override this method,
you can define your own objects, which can then be printed by
the usual \verb|println()| commands. In table \ref{tab:JavaLangObject}
all methods defined in \verb|java.lang.Object| are displayed.
\begin{table}[htbp]
  \begin{center}
\begin{small}
\begin{verbatim}
public boolean equals (Object obj);
protected Object clone() throws 
               CloneNotSupportedException, OutOfMemoryError;
public String toString ();
public int hashCode(); 
protected void finalize() throws Throwable;
\end{verbatim}
\end{small}
    \caption{All methods belonging to the (abstract) 
               \texttt{java.lang.Object} class.}
    \label{tab:JavaLangObject}
  \end{center}
\end{table}

If you want to find out about all methods and fields available
in the \verb|java.lang.object| class in detail, you just take
a look at the Java API docuementation of the JDK. There in the
package API documentation  you
click on the package \verb|java.lang| and then on the class
\verb|object| and you get the full description of the class
with all methods and fields.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The System Class: Screen-Output and Keyboard-Input}

Now we are in a place to discuss the \verb|System.out.println()| statement
already used in the ``HelloWorld'' program. This is calling the
\verb|println()| method of the \verb|PrintStream| class of the java.io 
package. And the \verb|out| is a variable from the System 
class of the java.lang package, referencing the \verb|PrintStream| class. 

There are also two more variables called \verb|err| and
\verb|in| for error output and data input. 
The java.lang.System class in general provides an platform-independent 
interface to some system functions.

Here an example, which demonstrates a few things already learned and
explains how to get input from the keyboard:
\inputlisting{Listings_Java/System_Class.java}
It waits for an user input and just echoes the typed characters
until you type the word ``Java''. Let us analyze the program:

First look at line 19, where we have used the \verb|print()| method
of the System class. It does the same as \verb|println()|, but does not
jump to the next line after the output.

Then take a look at line 23, where we compare two strings. As you see
you have to use the \verb|equals()| method of the String class to
compare the value of two strings and not the references. 
In line 25 we use the string concatenation operator $+$ for the output.

By the way, you have probably already noticed, that 
the \verb|for(;;)| loop in line 17 is a endless loop.

The actual input takes place in line 21, where we assign the input
to the string \verb|line|. The method used is \verb|readLine()|, which
is a method of the \verb|BufferedReader| class. It reads input until
a carriage return is reached. The actual object of the 
\verb|BufferedReader| class is created in line 13. To that end we have
to create a Reader class for the \verb|InputStream| called \verb|in|
just mentioned above (this is done in line 11).

Because we are using I/O commands, we have to take care of exceptions
which can occur during the I/O. For that reason we have to use the
\verb|throws IOException| statement in the definition of the main
class (see line 7).

A last remark concerns the escape codes used in line 15 and line 25.
The first one, $/$'' displays a quotation mark and the second
one a newline.
To include arbitrary formatting (escape) characters
to the string supplied to the print() and println() methods, you
can use similar to C the \verb|\n|, \verb|\t| or \verb|\\| codes
to get a newline, a tab or a backslash in the output. You should 
also note that, if you use e.g. \verb|System.out.println(5+7)| you
get \verb|12| as output, so if you want to see \verb|5 7| you have
to use \verb|System.out.print(5+" "+7)|.

Although this looks very complicated, if you don't want to go into
details, just copy this part to your own program and your are done.
But after you got used to object oriented programming you won't have
any problems understanding the code above anymore.

\subsubsection{Easy Input and Lava Rocks printf()}
\label{sec:LavaRocks}
Another easy solution is to use the \verb|EasyIn| and the
\verb|Printf()| methods, supplied by our \verb|simulation| class
and the ''Lava Rocks''\footnote{This is a freely available package,
containing some easy to use methods, mostly for C programmers
who switched to Java. For details see \cite{LavaRocks}.} package.

\paragraph{Easy Input}
You can easily use these methods to get input from keyboard
for different primitive data types. For example to input
a primitive data types, you just use
\begin{small}
\begin{verbatim}
import simulation.*;
 .....
 double  d = EasyIn.readDouble();    // reads double from System.in
 int     i = EasyIn.readInt();       // reads int from System.in
 float   f = EasyIn.readFloat();     // reads float from System.in
 boolean b = EasyIn.readBoolean();   // reads boolean from System.in
 .....
\end{verbatim}
\end{small}

\paragraph{Lava Rocks -- printf()/sprintf()/fprintf()}
To use the Lava Rocks package you could write a code like
\begin{small}
\begin{verbatim}
 import lava.clib.*;
 .....
 int i=100;
 float f=165.234f;
 Stdio.printf ( "%8d and %8.1f : test text\n", new Object [] { 
                             new Integer(i), new Float (f) } );
 .....                 
\end{verbatim}
\end{small}
Remember that you need the \verb|lava.jar| file in the classpath.
The output will look like
\begin{verbatim}
     100 and    165.2 : test text
\end{verbatim}
If you are familiar with the C routines, then you can find all
the modifiers used for formatting the different types of variables
in table \ref{tab:PrintfModifiers}.
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{cl}
      Modifier & Type to be formatted \\ \hline
      \%bd & byte \\
      \%hd & short \\
      \%d & signed integer \\
      \%ld & long \\
      \%u & unsigned integer \\
      \%o & unsigned octal integer \\
      \%x / \%X & unsigned hexadecimal integer (lower or uppercase)\\
      \%f & float \\
      \%lf & double \\
      \%e / \%E & float, scientific notation \\
      \%g / \%G & float, same as f or e, depending on value \\
      \%s & String \\
      \%c & character\\
      \%p & object identity hash code in unsigned hexadecimal \\
      \%$\backslash$n & platform independent line seprarator\\
      \%n & counts characters\\
    \end{tabular}
    \caption{All possible modifiers to be used in the format 
      string given to the printf()/sprintf()/fprintf() methods supplied 
      by the Lava Rocks package.}
    \label{tab:PrintfModifiers}
  \end{center}
\end{table}
The modifiers represent the place, where the actual value of the variable 
has to be inserted before the output is sent to the screen (or file, 
or string). So you have to make sure that the order of the modifiers and
the order of the supplied variables is correct, otherwise you get
unpleasant results or strange errors.

There are three additional things to mention: 
If you use the
same format string (the first argument to the printf method) 
very often, you can speed things up by saving the format string
and only use the variable every time, like:
\begin{small}
\begin{verbatim}
   import lava.clib.stdio.*;
   .....
   PrintfFormatString fmt = 
      new PrintfFormatString ("%8d and %8.1f : test text\n");
\end{verbatim}
\end{small}
Now you can use \verb|fmt| instead of the string in all printf commands
and it will be much faster.

There is also an ''easier'' way of using printf without creating
an object array, which is much more inefficient and should be avoided.

And there is a platform neutral code for newlines: Use \verb|%\n| instead
of \verb|\n| in the format strings and you always get a newline,
no matter which platform you run the program.

The same holds for the other two methods \verb|sprintf()|, which writes
the formatted output to a stringbuffer (we will discuss this in section
\ref{sec:FileIO} and in section \ref{sec:Symphony} in more detail.),
and \verb|fprintf()|, which writes the output to a file (actually a
Writer, see section \ref{sec:FileIO}).

There is another free implementation of the printf command for
Java called \verb|Format.java| of the \verb|corejava| package.
But it has much less functionality and so we decided to use
the Lava Rocks implementation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Passing Arguments to Methods}
\label{sec:PassingArguments}
We want to review all the aspects concerning the passing of
arguments to methods or -- for former FORTRAN programmers --
passing arguments to subroutines/functions.

\paragraph{Global Variables}
First of all there is of course always the possibility to 
pass variables as global variables. This is easy to use,
but it makes it difficult to follow a program structure.
So it is preferred to use arguments to methods in an
argument list.

\paragraph{Primitive Data Types}
The important point to note here is that Java always
passes primitive data types by value and all the other
arguments by reference (reference data types). 
This means that all primitive
variables of the argument list can be changed within
the method. The dummy variables used in the method 
can be viewed as local variables.

\paragraph{Reference Data Types}
But the reference data types (e.g. arrays, objects, etc.)
are passed by reference and therefore only the memory
address is passed to the method. That is again the reason that
by using the standard assignment or comparison operators,
you do not compare the values of the reference data type, but
the memory addresses where the data is stored. Therefore there
is the \verb|equals()| operator used for comparing reference data
types. By the way there is no method
of getting the actual memory address for a reference data type,
which would be a severe security problem.

If you pass a reference data type to a method it should be
clear, that every change of the dummy variable used for
the reference data type used in the method, will result in a change
of the passed reference variable. So for example for arrays:
\begin{lstlisting}{}
  .....
  public void main (String[] args) {
    ...
    int[] array = {1,2,3,4,5};
    test(array);
    ...
  }
  public void test(int[] dummyarray) {
    int length=dummyarray.length;
    for (int j=0; j<length; j++) {
      array[j]=0;
    }
  }
  .....
\end{lstlisting}
In this example we pass an array of integers, where the values are all 
not zero. In the subroutine we change the values of the 
\verb|dummyarray| array.
But we passed only the memory location, so the change is actually
a change in the \verb|array| array. If you print the result after
the call to the method, all elements are zero!

If you now think about changing a primitive data type inside a method 
passed to it, there is none. There is actually 
no simple way of using reference types for primitive data types to
change method parameters. 

\paragraph{Instance Variables}
A nice and clear way of passing arguments between methods, is
using instance variables. The problem here is that you have
to create a new class and define instance variables for it.
Then you can instantiate an object of this new class and
change the values of the instance variables from the main
program or the methods therein. But still you have the problem
of passing the instance to the methods.

\paragraph{Multi-Dimensional Arrays as arguments}
As a scientist you will always have the necessity to use arrays
as arguments to methods. There is actually no trouble with using
for example a 1D array to a method, which expects a 1D array. But 
what if you have a 2D array and the method needs a 1D array as
an argument? Should you copy a 1D row or column of the 2D array
into a new 1D array and then call the method or is there a better
way? 

The answer is yes, but not in all cases. You can always omit 
the last dimensions of an array. For example if you leave out
the second dimension of a 2D array, you get a 1D array, which is 
just the desired row of the array. But there is no way of referencing a
column. The following program demonstrates the usage.
\inputlisting{Listings_Java/testArray.java} 

\paragraph{Methods (Functions) as Arguments} 
Especially for scientists it is of great importance to know how
to pass a function (method) to another method.

The first solution would be to write a method as a class method,
therefore accessible from every instance of the class and
so you do not need to pass the method as an argument at all.

The second solution is much more versatile and general.
But as always you have to do more work. You need an interface,
which defines the function you would like to pass to a method
(Declaration). Then you need a class, which implements this
interface, therefore representing the real function (Implementation).
And at last you write your program/class, which instantiates
the former class and now you can pass the function by reference
to all methods you like (Usage).  

Here a short example:
\paragraph{Declaration} 
\begin{verbatim}
  interface function {
    double f (double x); 
  }
\end{verbatim}

\paragraph{Implementation}
\begin{verbatim}
  class SquareFunc implements function {
    public double f (double x) {
       return (x*x) ;    //  <----- here is the actual function
    }
  }
\end{verbatim}

\paragraph{Usage}
\loadlisting{TestPassingFunctions.java}{Listings_Java/TestPassingFunctions.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structure and Overview of Java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Keywords and APIs in Java 1.1 and Java 2}

Here we list all the standard packages (APIs) included in the Java 1.1
language standard. The important packages (for our purposes) are
written in small caps.

\subsubsection{Java 1.1 Packages}
\begin{description}
\item[\textsc{java.applet}] includes the superclass of all Java applets (small package)
\item[\textsc{java.awt}] the Abstract Windowing Toolkit (large package)
\item[java.awt.datatransfer] provides data exchange between programs
\item[\textsc{java.awt.event}] event handling for the AWT (Mouse, etc.)
\item[java.awt.image] rarely used classes for image processing (use AWT) 
\item[java.awt.peer] rarely used interfaces for the AWT
\item[java.beans] interfaces and classes for beans programmer
\item[\textsc{java.io}] all the input/output classes (very big)
\item[\textsc{java.lang}]  central Java language classes (largest package)
\item[java.lang.reflect] part of the Java Reflection API (small)
\item[\textsc{java.math}] arbitrary precision arithmetic (small)
\item[java.net] networking package
\item[java.rmi] RMI is Remote Method Invocation. It is a mechanism that enables an object on one Java virtual machine to invoke methods on an object in another Java virtual machine. 
\item[java.rmi.dgc] RMI distributed garbage-collection (DGC). 
\item[java.rmi.registry] Methods to access the RMI registry.
\item[java.rmi.server] RMI server classes and methods.
\item[java.security] A security framework. This includes classes that implement an easily configurable, fine-grained access control security architecture.
\item[java.security.acl / java.security.cert / java.security.interfaces / java.security.spec] Additional security features.
\item[java.sql] Provides the JDBC (Java Database Connectivity) package. JDBC is a standard API for executing SQL statements.
\item[java.text] for writing internationalized programs (date, time, etc.)
\item[\textsc{java.util}] useful classes, often used, e.g. millisecond time,
  calendar, random numbers, vectors, etc.
\item[java.util.zip] data compression and decompression classes
\end{description}

\subsubsection{Java 2 Packages}
Additional API packages in Java 2 are:
\begin{description}
\item[java.awt.color] Provides classes for color spaces.
\item[java.awt.dnd] Provides interfaces and classes for supporting drag-and-drop operations.
\item[java.awt.font] Provides classes and interface relating to fonts. It contains support for representing Type 1, Type 1 Multiple Master fonts,
OpenType fonts, and TrueType fonts. 
\item[java.awt.geom] The Java 2D classes for defining and performing operations on objects related to two-dimensional geometry. 
\item[java.awt.im] Classes and an interface for the input method framework. This framework enables all text editing components to receive Japanese, Chinese, or Korean text input through input methods. 
\item[java.awt.image.renderable] Classes and interfaces for producing rendering-independent images.
\item[\textsc{java.awt.print}] A general printing API, including document types, 
  page setup and formats and job control dialogs.
\item[java.beancontext] A bean context is a container for beans and defines the execution environment for the beans it contains.
\item[java.lang.ref] Provides reference-object classes, which support a limited degree of interaction with the garbage collector.
\item[java.rmi.activation] Provides support for RMI Object Activation.
\item[java.util.jar] For reading and writing the JAR (Java ARchive) file format, which is based on the standard ZIP file format with an optional manifest file. 
\item[javax.accessibility] Defines a contract between user-interface components and an assistive technology that provides access to those components. 
\item[\textsc{javax.swing}] Provides a set of "lightweight" (all-Java language) components that, to the maximum degree possible, work the same on all
platforms. 
\item[java.swingx.*] There are 15 more packages in the Swing package, which we are not describing here in detail. Take a look at the Swing tutorial or documentation.
\item[org.omg.COBRA] Provides the mapping of the OMG CORBA APIs to the JavaTM programming language, including the class ORB, which is implemented so that a programmer can use it as a fully-functional Object Request Broker (ORB).
\item[org.omg.*] 6 more packages are provided for using COBRA with Java. See the API documentation.
\end{description}

\subsubsection{Reserved words in Java}
The following words are reserved for Java and can not be used for names
of classes, variables or methods:
\begin{sverbatim}
abstract, boolean, break, byte, byvalue, case, cast, catch, char,
class, const, continue, default, do, double, else, extends,
false, final, finally, float, for, future, generic, goto, if,
implements, import, inner, instanceof, int, interface, long,
native, new, null, operator, oouter, package, private, protected, 
public, rest, return, short, static, strictfp, super, switch, 
synchronized, this, throw, throws, transient, true, try, var,
void, volatile, while, widefp
\end{sverbatim}

%%%%%%

\subsection{Name Conventions in Java}
In order to make the Java codes more readable it is customary to stick
to the followinh nam conventions.

\paragraph{Classes and Interfaces.} The names of classes and interfaces
  should consist of one or more words which are joponed together. They
  should describe appropriately the class and the interface. 
The first lette of the name is an uppercas letter. If the
  class name consists of more then one word each word after the first
  one begins with an uppercase letter, e.g., \verb|Needle|,
  \verb|Reader|, \verb|StringToken|.

\paragraph{Methods.} The names of methods are verbs or verb--phrases. 
  They begin with lowercase letters. If the name consists of
  more than one word, the second and all the following words begin
  with an uppercase letter. To give some examples:
\begin{itemize}
\item methods, which set the value of a variable or return the value of
  a variable begin with \verb|set| or \verb|get|; e.g.,
  \verb|setName|, \verb|getData|.
\item methods, which check some condition and return a result  get the
  prefix \verb|is|, e.g., \verb|isSmaller|.
\item methods, which simply perform some conversions are characteized
  by the returned type and have the prefix \verb|to|, e.g.,
  \verb|toString|.
\end{itemize}
If you stick to these rules you are already writing programs, which
conform to the Java beans syntax. This means you can take your
programs and use them as beans later on with almost no changes
(see section \ref{sec:Beans}).


\paragraph{Instance Variables.} Names for instance variables are
  words, nominal phrases, or short--hand notations. Like names for
  methods the word begins with a lowercase letter and all following
  words begin with an uppercase letter, e.g., \verb|next|,
  \verb|dataVector|,
\verb|minValue|.

\paragraph{Local variables or parameters.} Local variables should get
  short  names. Usually, they are named by sequences of small
  letters. Typical examples are acronyms (the first letter of each
  word) of the name of the class for a variable, which keeps a
  reference to an instanace of the class, e.g., \verb|rv| for Random
  Variable or short--hand notations, e.g., \verb|minx| for the minimal
  value of the variable x. Single letter names should be avoided,
  unless for temporary variables or variables, which are used in
  loops or for variables with an uncertain value of some type:
\verb|b| for \verb|byte|, \verb|c| for \verb|char|, \verb|d| for
  \verb|double|, \verb|e| for Exception, \verb|f| for \verb|float|,
  \verb|i|,
\verb|j|, \verb|k| for \verb|int|, \verb|l| for \verb|long|, \verb|o|
  for \verb|Object|, \verb|s| for \verb|String|.

\paragraph{Constants.} The names of constants may be composed by one
  or more words. All characteres are upper--case letters and the words
  are joined by \verb|_|, e.g., \verb|PI|,  \verb|MIN_VALUE|.

\paragraph{Packages.} Packages, which are only used locally are
  identified by a name which begins with a lower--case letter. This
  word can not be \verb|java|; this keyword is reserved for
  standard Java classes.



\subsection{Java Documentation}
As the time of writing the JDK (1.1 or 2) is distributed in
two parts. The first one is the Java Runtime Environement called JRE
(the Java virtual machine and the plugin for the internet explorer
and netscape to run Java applets) and the complete package,
which includes the JRE and additionally has all the necessary
development tools.
The API documentation is included in the full package, but not
in the JRE. The documentation is also available seperately.

In the directory \verb|JAVA_HOME|, on UNIX this could be 
\verb|/usr/local/jdk1.2|, \verb|/usr/local/lib/jdk1.2| or 
\verb|/usr/lib/jdk1.2| and on Windows this might be \verb|c:\jdk1.2|, 
you can find all the documentation in the subdirectory
\verb|docs|. It is of course best viewed using a web browser
starting with the page \verb|jdk1.2/docs/index.html| 
(see also figure \ref{fig:JDKFiles}).
\begin{figure}[htbp]
  \begin{center}
    \includegraphics[width=.6\textwidth]{Figures/JDKDocumentation.eps}
    \caption{The file structure of the JDK distribution, both the binary and the documentation package.}
    \label{fig:JDKFiles}
  \end{center}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Applications and Applets Revisited}

After discussing object oriented programming,
we want to recapitulate the basic differences and features of
the two possible ways of writing and starting Java programs.

\subsection{Applications}
A Java application is in the traditional language a ``normal'' program.
In Java slang it is a class, which only has to have a \verb|main|
method, which has to be \verb|static| and \verb|public|. This is also of course the
entrance point, if you start the Java application. Then the program
executes sequentially the code given in the main method (of course it
goes parallel, if you use threads somewhere in the application - see
\ref{sec:ParallelJava}). There are no restrictions of any sort using
features in an application.


\subsection{Applet}
An applet is a Java class, which can be loaded into a virtual machine
and can then be executed their. For example a web browser could load
the applet, check if it is an applet allowed to be started on the
machine the browser is running on and then ``starts the applet''.

This is basically the most confusing part of an applet: What are the
instructions, which get executed when the browser ``starts the applet''?
To that purpose go ahead and write a simple program 
(see e.g. \verb|ShowTrace.java|), which only 
prints out the place where the execution just takes place and ``start''
the Java class on the command line as an application, in the appletviewer
as an applet and in a browser as an applet. What you will get is shown
in figure \ref{fig:LineOfExecution}.
\begin{figure}[htbp]
  \begin{center}
    \leavevmode
    \includegraphics[width=\textwidth]{Figures/LineOfExecution.eps}
    \caption{The line of execution in an application and an applet in
        the appletviewer or the Netscape Navigator V4.08. For the application
        only the part above the first line and below the second line are
        actually the parts, which can not be avoided. The remaining
        part is just provided to show you how to write an application,
        which can be used as an applet, too.}
    \label{fig:LineOfExecution}
  \end{center}
\end{figure}

So for the applets you have to write (implement) at least the 
\verb|init()| method to get things going. But now you will ask, why did we
not supply an  \verb|init()| method when we wrote our first 
HelloWorld applet? The answer is we did, but we did not write it explicitly,
because we left it empty. The trick was that for an applet there is
always another thread (see \ref{sec:ParallelJava} for an introduction to threads)
running, which takes care of (re)painting the windows (panels) used by the applet.
This thread is a method of the AWT package (see \ref{sec:AWTIntro}) and
the method is the \verb|paint()| method. And in the    HelloWorld applet
we have overriden the \verb|paint()| method to display our message.

Actually the threads and methods used for painting and repainting
the windows or panels is a little bit more tricky and involved, so we
have to postpone the discussion to a later chapter. Here only the basics:
There is a method \verb|repaint()|, which calls the \verb|update()|
method and that in turn calls the \verb|paint()| method, when there is time
to do so. This sounds very complicated in the first place, but 
it will be resolved later on.

There is another issue to be addressed here in the context of applets.
So far we have always written a seperate HTML file to use with the
appletviewer, which then in turn calls the applet itself. The burden
of having two files for one applet can be avoided by putting the
HTML Code at the beginning of the Java class file in a comment. Then
if you call the appletviewer with the Java class file 
it executes the HTML code supplied
in the Java class file and starts the applet. It even starts in
the Netscape Navigator, although it probably makes no sense for
large programs embedded in a set of HTML pages kept uptodate in a
different way as the Java source code. But it certainly eases
writing small applets and getting not confused by too many files on
your disks. 

Here a small example showing the described feature:
\inputlisting{Listings_Java/test_Applet.java}
You can start it (first you have to compile it) 
by typing \verb|appletviewer test_applet.java| or 
in the Netscape Navigator type 
\verb|file:/home/user/test_Applet.java|\footnote{You have to substitute 
the path by an appropiate one for your system and configuration.}.
Then on the command line or the terminal with which you started the browser  
you see the short message.


\subsection{Programs as Applets and Applications}
To write a class to be run as an applet and an application
you can use figure \ref{fig:LineOfExecution} to get the correct order
of the methods, which get called in either case. As an example, 
we have used the following philosophy in later chapters for the 
bigger programs
to have them run as an applet as well as a standalone application:
\inputlisting{Listings_Java/TestAppletApplication.java}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Higher Mathematics in Java}

\subsection{Standard Mathematical Functions in Java}
\label{sec:Standard_Math}

The standard mathematical functions of Java are declared in the 
java.lang.Math class, which consists of static constants and methods
for common mathematical manipulations. 
It contains sine, cosine, logarithm, exponential,
square root and much more. Do not confuse this class with the
java.Math class, which was introduced to Java 1.1 for arbitrary
precision arithmetic -- we are not discussing this, read the
API documentation for details.

Java math is always conforming to the IEEE 754 standard and all
algorithms used in the math API are guaranteed to produce the
same results as those from netlib's 
\emph{Freely Distributable Math Library}\footnote{Called \texttt{fdlibm}.
Netlib is a collection of mathematical software, papers and databases.
It is located at the ORNL (Oak Ridge National Lab in Tennessee) and UTK (University
of Tennessee at Knoxville), but there are many other mirror sites.
Fdlibm is available online from 
\href{http://www.netlib.org/}{http://www.netlib.org/} or
\href{http://www.hensa.ac.uk/ftp/mirrors/netlib/}%
           {http://www.hensa.ac.uk/ftp/mirrors/netlib/}}.
\verb|fdlibm| is a C library for machines supporting the IEEE 754 floating
point artihmetic initially developed by SUN.

Some useful constant in the \verb|Math| class  are \verb|Math.Pi|
($\pi$) and \verb|Math.E| ($e$).
In table \ref{tab:math_table} 
we have summarized some of the most useful methods in the \verb|Math| class. 
Note, that all angles are in radians and all parameters and
return values are double (unless otherwise stated). 
\begin{table}[htbp]
\caption{Some useful mathenatical fuinctions defined in the
  java.lang.Math class.}
  \begin{center}
    \leavevmode
    \begin{tabular}{ll}
      abs(x) & absolute value \\
      acos(x)/asin(x)/atan(x) & arcus cosine/sine/tangent \\
      atan2(x,y) & arctangent (x/y)  \\
      sin(x)/cos(x)/tan(x) & sine/cosine/tangent\\
      exp(x) / log(x) & exponential and natural logarithm \\
      ceil(x) & smallest whole number $\ge x$ \\
      floor(x) & largest whole number $\le x$ \\
      rint(x) & x rounded to the nearest integer; \\
             &  if neither integer is
                        nearer, rounds to the even one. \\
      round(x) & (int) floor (x+0.5) for float x \\
       ~       & (long) floor(x+0.5) for double x \\
      pow(x,y ) & $y^x$\\
      min(x,y)/max(x,y)  & minimum (maximum)  of x and y for any numeric type  \\
      sqrt(x) & square root of a double x\\
      random() & random numbers (use java.util.Random class)\\
      IEEEremainder(x) & special remainder function \\\hline
      & \textbf{New in Java 2:} \\
      toRadians(angle) & converts degrees to radians\\
      toDegrees(rad) & converts radians to degrees \
    \end{tabular}
    \caption{Overview of the mathematical methods available in Java 1.1 in the java.lang.Math class.}
    \label{tab:math_table}
  \end{center}
\end{table}

These are all class methods, so they can be called from anywhere.
Here are some examples:
\begin{sverbatim}
 a=Math.exp(2.1);        // e to the 2.1
 distance = Math.sqrt(Math.pow(x,2)+Math.pow(y,2));  // Euclidean distance
\end{sverbatim} 
By the way, there is no easy import statement to avoid the Math in front
of the methods, you always have to use it, although it seems 
tedious.

Here is a test program for the three rounding methods available:
\inputlisting{Listings_Java/Test_Roundings.java}
And the output is:
\input{Listings_Java/Test_Roundings.output}

For most of our simulations, we will need routines (methods) to
calculate the mean, variance or other statistical measures of
a times series for example. Unfortunately
these (easy and) important methods are not part of the
standard Java language. But Visual Numerics, a well known software company,
has proposed a standard class for statistical functions, which are
essential for all statistical problems. They also supplied a new class
for complex numbers. This library is called the Java Numerical Library
(JNL) and is free. It is also proposed to become a standard in the
next Java language specification.

There are also other classes, which extend the standard Java language
for matrix computations (BLAS) and much more (e.g. the JNT). Some of 
them will be discussed in greater detail now.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Numerical Libraries - The JNL}
The JNL (Java Numerical Library) was designed and implemented by 
Visual Numerics. It is a free library to supply additional 
mathematical functions, complex numbers, statistical operations 
and some basic vector and matrix operations for scientists (no
sparse matrix support), which
are missing in the Java standard. They have proposed it as a
standard for the next version of Java.

The algorithms used are taken from the LinPack library, which
are a collection of programs for linear algebra in C and Fortran.
A short list of some of the functions included in the JNL is
given in table \ref{tab:JNL}.
\begin{sidewaystable}[htbp]
    \begin{tabular}{>{\large}c||>{\scriptsize}l|l}
      \textbf{Class}  & \normalsize\textbf{example methods} & \textbf{purpose} \\\hline\hline
      SFun &  & Special Functions \\
           & \verb|public static double sinh(double x)| & hyperbolic sine function \\
           & \verb|public static double gamma(double x)| & the gamma function \\
           & \verb|public static double erf(double x)| & the error function \\\hline
      Statistics &  & Statistical functions \\
           & \verb|public static double average(double[] x)| & the sample mean\\
           & \verb|public static double normalCDF(double x)| & 
                             cummulative normal distribution function\\
           & \verb|public static double[] linearFit(double[] x, double[] y)| &
                             linear least square estimator \\\hline
      Complex &  & for handling complex numbers \\\hline
      DoubleVector &  & using vector operations on arrays of type double\\
      ComplexVector & & the same for complex vectors \\\hline 
      DoubleMatrix &  & using matrix operations on 2D arrays of type double\\
      ComplexMatrix & & the same for complex matrices \\\hline 
    \end{tabular}
    \caption{A (very) short list of JNL classes supplied with JNL 1.0 revision f for the new JDK 1.2. There are two 1.0f versions around, one which works with both Java 1.1 and Java 2 and one which has some trouble with Java 2.}
    \label{tab:JNL}
\end{sidewaystable}
Eight more classes (four for double and four for complex) for
matrices are provided, which perform matrix decompositions,
like Cholesky, LU, QR and SVD decompositions. They can be
used for an efficient solution to linear systems of equations.
 
For a complete list of supplied functions, please consult the online 
documentation coming with the JNL package.

\paragraph{Complex numbers}
This part of the JNL deserves a seperate discussion. We will not need
complex numbers in most parts of the book, but for example when
we discuss quantum mechanical problems, we have to come back to
treating complex numbers in Java.

Because complex numbers are not a primitive data type in Java (yet),
and there is no operator overloading like in C++ for example, we
can not write \verb|a+b|, if a and b are complex numbers. We have to
create a new object called Complex and define methods to work with
these objects. This is exactly the solution followed by the JNL,
so we do not need to do it again.

To instantiate complex numbers issue 
\begin{sverbatim}
import VisualNumerics.math.*;
  ......
  Complex c1 = new Complex(1,2); // means c1 = 1+2i  
  Complex c2 = new Complex(2);   // means c2 = 2  
  System.out.println(c1);  // gives   1+2i  on screen
  ......
\end{sverbatim}
By the way you can change the output character for the complex
unit \verb|i| by using \verb|Complex.suffix="j";| for example.

To add two complex numbers use one of the two possible methods:
\begin{sverbatim}
   Complex cresult1 = Complex.add(c1,c2);
   Complex cresult2 = c1.add(c2);
\end{sverbatim}
The first version is the static method and the second one is
the instance method of the class Complex. There are analogous
static methods for \verb|Complex.subtract(c1,c2)|, \verb|Complex.divide(c1,c2)|
and \verb|Complex.multiply(c1,c2)| and of course the same with
instance methods.

You can extract real and imaginary part from a complex number
easily by using
\begin{sverbatim}
  Complex c1 = new Complex(2,5);
  System.out.println(" Real part: "+c1.re);
  System.out.println(" Imaginary part: "+c1.im);
\end{sverbatim}

An overview of the most important methods is given in table 
\ref{tab:JNLComplex}.
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{l|l}
      \verb|Complex.abs(z)| & absolute value \\
      \verb|Complex.argument(z)| & the argument of the complex number z \\
      \verb|Complex.conjugate(z)| & conjugate of z  \\
      \verb|Complex.sqrt(z)| & the square root of z \\
      \verb|Complex.pow(z1,z2)| & the power of z1 to the z2\\
      \verb|Complex.pow(z,d)| & the power of z to the (double) d\\
      \verb|Complex.exp(z)| & the natural exponential of z \\
      \verb|Complex.sin(z)| & the sine of z \\
    \end{tabular}
    \caption{An overview of the most important methods supplied by the 
      Complex class of the JNL. z represents a complex number 
      (\texttt{Complex z;}).}
    \label{tab:JNLComplex}
  \end{center}
\end{table}


\subsection{The JSci/JavaSci Package}
\label{sec:JSci}
The JavaSci package has been developed at the
\emph{Imperial College of Science, Technology and Medicine} in the UK.
It is a freely available scientific package and its objective is:
\begin{quote}
``JavaSci aims to encapsulate scientific principles and ideas in a way 
that is representative of their underlying structure and usage.''
\end{quote}

The package consists of basically two types of classes: representation 
classes and library classes. The representation classes are instaniateable
and represent some physical or mathematical structure, whereas the
library classes are not to be instantiated and are used to manipulate
the representation classes.

The \verb|JSci| package is split into a 
\verb|chemistry|, a \verb|physics| and a \verb|maths| subclass.
Then there are many convenience classes and some interesting other classes.
The best way to learn the package is to study the API documentation. 
In table \ref{tab:JSciClasses} we give a short overview of interesting 
classes and methods in the JavaSci package used throughout the book.
\begin{sidewaystable}[htbp]
  \begin{center} \small
    \begin{tabular}{ll}
      \verb|JSci.chemistry.Atom| & Used to construct and store an atom 
                                   with all the data necessary.\\
      \verb|JSci.chemistry.Element| & Used to construct and store an element 
                                   with all the data necessary.\\
      \verb|JSci.chemistry.Molecule| & Used to construct and store a molecule 
                                   with all the data necessary.\\
      \verb|JSci.chemistry.periodictable.TransitionMetal| & The full periodic
         table with all data\\\hline
      \verb|JSci.maths.Mapping| & An interface to define 1D complex or real
                functions.\\
      \verb|JSci.maths.NMapping| & An interface to define N dimensional 
                complex or real functions.\\\hline
      \verb|JSci.maths.ArrayMath| & All kinds of array methods to make
                  life easier. Many more as in the Java 2 array class. \\
\verb|JSci.maths.ArrayMath.correlation()| & 
              Compute the (linear) correlation between two arrays. \\
\verb|JSci.maths.ArrayMath.norm()| & 
       Compute the L2 norm of an array (Euclidean norm or length). \\
\verb|JSci.maths.ArrayMath.normalize()| & 
   Normalize the array so that its L2 norm is 1 (up to computational errors).\\
\verb|JSci.maths.ArrayMath.print()| & Print a 1D or 2D array to the screen\\
 \verb|JSci.maths.ArrayMath.sumSquares()| & 
   Sum the squares of all components; also called the energy of the array. \\
 \verb|JSci.maths.ArrayMath.toString()| & 
  Returns a comma delimited string representing the value of the array. \\\hline
\verb|JSci.maths.FourierMath| & Methods for 1D real or complex FFTs.\\
\verb|JSci.maths.FourierMath.transform()| & A 1D complex or double fast 
        Fourier transformation.\\\hline
\verb|JSci.maths.LinearMath| & Eigenvalues, eigenvectors, linear least squares
           and solving linear systems.\\\hline
\verb|JSci.maths.NumericalMath| &  Numerical differentitation, integration, 
        ODEs, Metropolis algorithm \\
\verb|JSci.maths.NumericalMath.rungeKutta()| & Uses the Runge-Kutta 
              method to solve an ODE.\\\hline
\verb|JSci.maths.WaveletMath| & All kinds of methods for wavelets.\\\hline
\verb|JSci.maths.statistics| & A class with many important complicated 
              distributions (Beta, Gamma, T, ChiSquared, etc.)\\\hline
\verb|JSci.physics.PhysicalConstants| & All physical constants you 
                               can think of.\\\hline
\verb|JSci.physics.quantum.KetVector| & Creating vectors for wuantum 
             mechanics.\\
\verb|JSci.physics.quantum.DensityMatrix| & Calculate the density matrix.\\\hline
\verb|JSci.util.MatrixToolkit| & Methods to create random matrices 
                 and some conversions.\\\hline
\verb|JSci.io| & Reading/Writing text files and writing MathML (XML) files.\\\hline
\verb|JSci.awt| & Graphical routines like plotting for the AWT.\\
\verb|JSci.awt.BarGraph()| & A bar graph AWT component. \\
\verb|JSci.awt.ContourPlot()| & A contour plot AWT component. \\
\verb|JSci.awt.LineGraph()| & A 2D line graph AWT component. \\
\verb|JSci.awt.LineGraph3D()| & A 3D line graph AWT component. \\
\verb|JSci.awt.PieChart()| & A pie chart AWT component. \\
\verb|JSci.awt.ScatterGraph()| & A scatterGraph AWT component. \\\hline
\verb|JSci.swing| & The same for the swing package.\\
     \end{tabular}
    \caption{Some of the interesting classes and methods in 
      the JSci/JavaSci package.}
    \label{tab:JSciClasses}
  \end{center}
\end{sidewaystable}
The \verb|JSci.maths.ArrayMath| class also contains methods for
calculating the mean, variance, standard deviation, etc. like
the JNL. The \verb|JSci.maths| package  
contains many methods and classes for handling matrices
either integer, double, complex, sparse or diagonal and more. It has methods
for handling vectors in all flavours. And it even provides functionallity
for discrete sets and the construction of the Karhunen-Loeve expansion. 
There are complex numbers, special functions like hyperbolic ones
and in the \verb|SpecialMath| math class there are even more like
the Bessel functions, Airy functions, incomplete Gamma and Beta functions, etc.
Another class can handle symmetry groups, one handles chaotic maps and
almost everything you wish about wavelets in many different classes.

In the \verb|JSci.physics| class you get methods and classes to use
particles. There is a whole class just defining all kinds of particles
known to physicists today. Then you can use the \verb|JSci.physics.quantum|
class to do quantum mechanics caluclations easily or you could use
the \verb|JSci.physics.relativity| class to do relativistic calculations.

Because it is the only (free) way of producing 3D graphs yet, we have 
given an example in figure \ref{fig:JSci3DGraph}. 
\begin{figure}[htbp]
  \begin{center}
    \includegraphics[angle=90,width=\textwidth]{Figures/JSciGraph3D.eps}
    \caption{An example of the 3D plotting capabilities of JSci.}
    \label{fig:JSci3DGraph}
  \end{center}
\end{figure}
You see it is actually not what you expected, but it is a beginning.
You can also use the mouse to rotate the 3D graph 
in the right half of the window. The graph on the left is a contour plot.
\loadlisting{JSci3DGraph.java}{Listings_Java/JSci3DGraph.java}

Since version 0.82 there is the IBM MathML package included to write 
XML/MathML files from Java. That is the reason why now there is a
limitation in the use of the whole package. So go ahead and read the license
agreement in the online documentation.

In our opinion, you should use the JNL and ptplot if possible. Only for
methods not contained in these two packages you should use the
JSci package like FFT or solving ODEs for example. JSci is still in
the development phase and it takes some more time to be really
the package of choice for most of the tasks.   

\subsection{JNT, Lapack for Java - JamPack and Jama}
????
\subsubsection{JNT}
\subsubsection{Lapack}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Debugging in Java}
????

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Advanced Java Features}

\subsection{Including Native Code (C and C++)}
To include native code into a Java program, there is the so-called
JNI (Java Native Interface). This allows for inclusion of native
C or C++ codes. To refer to such a method, you just use
\begin{verbatim}
     ...
     native CFunction();
\end{verbatim}
The code for the method has to be implemented in C or C++.

At the moment there is no direct interface to other languages like
Fortran. If you want to include Fortran code you have to use
a C wrapper code and then use the JNI with that C wrapper code
for inclusion to Java.

\subsection{Vectors}
For a scientists there is a confusing class called \verb|java.util.Vectors|, 
which has nothing to do with mathematical vectors. This class realizes
an array of objects, which can have a variable length. For example
you can store names of persons in an vector and add or delete them as
you like without taking care of the number and the access. For details
refer to the API documentation.

\subsection{Stack}
There is also a class \verb|java.util.Stack|, which utilizes as the
name suggests a stack. A stack is a kind of pile, where you can put
things on it and take them away, but only the last one put in. It is
for example used for many operating system tasks on a lower level.
Again take a look at the API documentation for details.

\subsection{Hashtable}
Another often occuring class of the \verb|java.util| package is the
hashtable class. It realizes a table with associations between so-called
keys and values, which has to be a one-to-one correspondence. So for
example you can store the name of a person and its age in a hashtable.


\subsection{Serialization}
One problem of objects is how to ``save'' objects to disk for example.
Or sometimes you want to submit an object to another applet or
application using RMI accross networks, or you might want to
store the object for the next call of the same program (called 
persistence). 

For all
these reasons and many more, there is a method called serialization,
which transforms an object in a byte stream and back. 
To save an object to a file for later use, you could easily serialize
the object and store the byte stream to a file. Later on you reread
the file and deserialize the byte stream back to an object. 

If you create your own classes and want objects (instances of your 
class) to be serializable you have to implement the serializable interface.
We do not need this in the context of this book, but it is
important to know what is behind this.  

\subsection{Beans}
\label{sec:Beans}
Beans are classes, which conform to certain naming rules
for the methods contained in a class. A bean gets a graphical
representation (an icon) and can be used in a separate program
(often called the beanbox) to create an application by just
putting together different beans and changing the resources
of the bean. 

For example we can use a plot bean, which displays a plot (see
ptplot later on). Then you can place this plot bean on the screen
and change the title, axes, etc. Then you can add a bean, which
creates random numbers and type in the size of the set. Then
you can connect the two beans, which automatically sends the
data to the plot bean and plots it. This is called visual 
programming and is used in programs as IBM Data Explorer or
AVS/Express to write programs mostly including visual 
interfaces (GUIs).

You can for example write your own graphical beans and import them 
into one of the IDEs like Simplicity or Netbeans. Then you can 
use your own bean to construct a nice GUI.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Online References}
\label{sec:OnlineReferences}

\href{http://java.sun.com/}{http://java.sun.com/} is the homepage of
Java from SUN. A good starting point. \\

\href{http://www.javasoft.com/}{http://www.javasoft.com/} \\

??????


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exercises}
Pi Calculation:
\lstinputlisting{Listings_Java/Pi_Calc_plain.java}
\lstinputlisting{Listings_Java/Pi_Calc.java}

radioactive decay, e calc.
Moment calulation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\nocite{FLANAGAN-EXAMPLES}
\nocite{GOSLING}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{peter}
\bibliography{V_98,simulit}

